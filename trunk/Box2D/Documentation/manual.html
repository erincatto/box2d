<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 12 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Cambria;
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:Consolas;
	panose-1:2 11 6 9 2 2 4 3 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
h1
	{mso-style-link:"Heading 1 Char";
	margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	text-indent:0in;
	page-break-before:always;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:18.0pt;
	font-family:"Cambria","serif";
	color:#0B5294;}
h1.CxSpFirst
	{mso-style-link:"Heading 1 Char";
	margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	page-break-before:always;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:18.0pt;
	font-family:"Cambria","serif";
	color:#0B5294;}
h1.CxSpMiddle
	{mso-style-link:"Heading 1 Char";
	margin:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	page-break-before:always;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:18.0pt;
	font-family:"Cambria","serif";
	color:#0B5294;}
h1.CxSpLast
	{mso-style-link:"Heading 1 Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	text-indent:0in;
	page-break-before:always;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:18.0pt;
	font-family:"Cambria","serif";
	color:#0B5294;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	text-indent:0in;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:13.0pt;
	font-family:"Cambria","serif";
	color:#0F6FC6;}
h2.CxSpFirst
	{mso-style-link:"Heading 2 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:13.0pt;
	font-family:"Cambria","serif";
	color:#0F6FC6;}
h2.CxSpMiddle
	{mso-style-link:"Heading 2 Char";
	margin:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:13.0pt;
	font-family:"Cambria","serif";
	color:#0F6FC6;}
h2.CxSpLast
	{mso-style-link:"Heading 2 Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	text-indent:0in;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:13.0pt;
	font-family:"Cambria","serif";
	color:#0F6FC6;}
h3
	{mso-style-link:"Heading 3 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#0F6FC6;}
h4
	{mso-style-link:"Heading 4 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#0F6FC6;
	font-style:italic;}
h5
	{mso-style-link:"Heading 5 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#073662;
	font-weight:normal;}
h6
	{mso-style-link:"Heading 6 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#073662;
	font-weight:normal;
	font-style:italic;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{mso-style-link:"Heading 7 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{mso-style-link:"Heading 8 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#404040;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{mso-style-link:"Heading 9 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:11.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:22.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#03485B;
	letter-spacing:.25pt;}
p.MsoTitleCxSpFirst, li.MsoTitleCxSpFirst, div.MsoTitleCxSpFirst
	{mso-style-link:"Title Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#03485B;
	letter-spacing:.25pt;}
p.MsoTitleCxSpMiddle, li.MsoTitleCxSpMiddle, div.MsoTitleCxSpMiddle
	{mso-style-link:"Title Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#03485B;
	letter-spacing:.25pt;}
p.MsoTitleCxSpLast, li.MsoTitleCxSpLast, div.MsoTitleCxSpLast
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#03485B;
	letter-spacing:.25pt;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{mso-style-link:"Subtitle Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Cambria","serif";
	color:#0F6FC6;
	letter-spacing:.75pt;
	font-style:italic;}
a:link, span.MsoHyperlink
	{color:#0B5294;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:#85DFD0;
	text-decoration:underline;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-link:"Balloon Text Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:8.0pt;
	font-family:"Tahoma","sans-serif";}
p.MsoNoSpacing, li.MsoNoSpacing, div.MsoNoSpacing
	{mso-style-link:"No Spacing Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoQuote, li.MsoQuote, div.MsoQuote
	{mso-style-link:"Quote Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:black;
	font-style:italic;}
p.MsoIntenseQuote, li.MsoIntenseQuote, div.MsoIntenseQuote
	{mso-style-link:"Intense Quote Char";
	margin-top:10.0pt;
	margin-right:.65in;
	margin-bottom:14.0pt;
	margin-left:.65in;
	page-break-after:avoid;
	background:white;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:#595959;}
p.MsoIntenseQuoteCxSpFirst, li.MsoIntenseQuoteCxSpFirst, div.MsoIntenseQuoteCxSpFirst
	{mso-style-link:"Intense Quote Char";
	margin-top:10.0pt;
	margin-right:.65in;
	margin-bottom:0in;
	margin-left:.65in;
	margin-bottom:.0001pt;
	page-break-after:avoid;
	background:white;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:#595959;}
p.MsoIntenseQuoteCxSpMiddle, li.MsoIntenseQuoteCxSpMiddle, div.MsoIntenseQuoteCxSpMiddle
	{mso-style-link:"Intense Quote Char";
	margin-top:0in;
	margin-right:.65in;
	margin-bottom:0in;
	margin-left:.65in;
	margin-bottom:.0001pt;
	page-break-after:avoid;
	background:white;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:#595959;}
p.MsoIntenseQuoteCxSpLast, li.MsoIntenseQuoteCxSpLast, div.MsoIntenseQuoteCxSpLast
	{mso-style-link:"Intense Quote Char";
	margin-top:0in;
	margin-right:.65in;
	margin-bottom:14.0pt;
	margin-left:.65in;
	page-break-after:avoid;
	background:white;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:#595959;}
span.MsoIntenseEmphasis
	{color:#0F6FC6;
	font-weight:bold;
	font-style:italic;}
p.MsoTocHeading, li.MsoTocHeading, div.MsoTocHeading
	{margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	text-indent:0in;
	page-break-before:always;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:18.0pt;
	font-family:"Cambria","serif";
	color:#0B5294;
	font-weight:bold;}
p.MsoTocHeadingCxSpFirst, li.MsoTocHeadingCxSpFirst, div.MsoTocHeadingCxSpFirst
	{margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	page-break-before:always;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:18.0pt;
	font-family:"Cambria","serif";
	color:#0B5294;
	font-weight:bold;}
p.MsoTocHeadingCxSpMiddle, li.MsoTocHeadingCxSpMiddle, div.MsoTocHeadingCxSpMiddle
	{margin:0in;
	margin-bottom:.0001pt;
	text-indent:0in;
	page-break-before:always;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:18.0pt;
	font-family:"Cambria","serif";
	color:#0B5294;
	font-weight:bold;}
p.MsoTocHeadingCxSpLast, li.MsoTocHeadingCxSpLast, div.MsoTocHeadingCxSpLast
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	text-indent:0in;
	page-break-before:always;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:18.0pt;
	font-family:"Cambria","serif";
	color:#0B5294;
	font-weight:bold;}
span.TitleChar
	{mso-style-name:"Title Char";
	mso-style-link:Title;
	font-family:"Cambria","serif";
	color:#03485B;
	letter-spacing:.25pt;}
span.SubtitleChar
	{mso-style-name:"Subtitle Char";
	mso-style-link:Subtitle;
	font-family:"Cambria","serif";
	color:#0F6FC6;
	letter-spacing:.75pt;
	font-style:italic;}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Cambria","serif";
	color:#0B5294;
	font-weight:bold;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Cambria","serif";
	color:#0F6FC6;
	font-weight:bold;}
span.IntenseQuoteChar
	{mso-style-name:"Intense Quote Char";
	mso-style-link:"Intense Quote";
	color:#595959;
	background:white;}
span.NoSpacingChar
	{mso-style-name:"No Spacing Char";
	mso-style-link:"No Spacing";
	font-family:"Times New Roman","serif";}
span.BalloonTextChar
	{mso-style-name:"Balloon Text Char";
	mso-style-link:"Balloon Text";
	font-family:"Tahoma","sans-serif";}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Cambria","serif";
	color:#0F6FC6;
	font-weight:bold;}
p.CodeBlock, li.CodeBlock, div.CodeBlock
	{mso-style-name:CodeBlock;
	mso-style-link:"CodeBlock Char";
	margin-top:0in;
	margin-right:.25in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	page-break-after:avoid;
	background:#F2F2F2;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:Consolas;}
p.CodeBlockCxSpFirst, li.CodeBlockCxSpFirst, div.CodeBlockCxSpFirst
	{mso-style-name:CodeBlockCxSpFirst;
	mso-style-link:"CodeBlock Char";
	margin-top:0in;
	margin-right:.25in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	page-break-after:avoid;
	background:#F2F2F2;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:Consolas;}
p.CodeBlockCxSpMiddle, li.CodeBlockCxSpMiddle, div.CodeBlockCxSpMiddle
	{mso-style-name:CodeBlockCxSpMiddle;
	mso-style-link:"CodeBlock Char";
	margin-top:0in;
	margin-right:.25in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	page-break-after:avoid;
	background:#F2F2F2;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:Consolas;}
p.CodeBlockCxSpLast, li.CodeBlockCxSpLast, div.CodeBlockCxSpLast
	{mso-style-name:CodeBlockCxSpLast;
	mso-style-link:"CodeBlock Char";
	margin-top:0in;
	margin-right:.25in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	page-break-after:avoid;
	background:#F2F2F2;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:Consolas;}
span.CodeBlockChar
	{mso-style-name:"CodeBlock Char";
	mso-style-link:CodeBlock;
	font-family:Consolas;
	background:#F2F2F2;}
span.Heading4Char
	{mso-style-name:"Heading 4 Char";
	mso-style-link:"Heading 4";
	font-family:"Cambria","serif";
	color:#0F6FC6;
	font-weight:bold;
	font-style:italic;}
span.Heading5Char
	{mso-style-name:"Heading 5 Char";
	mso-style-link:"Heading 5";
	font-family:"Cambria","serif";
	color:#073662;}
span.Heading6Char
	{mso-style-name:"Heading 6 Char";
	mso-style-link:"Heading 6";
	font-family:"Cambria","serif";
	color:#073662;
	font-style:italic;}
span.Heading7Char
	{mso-style-name:"Heading 7 Char";
	mso-style-link:"Heading 7";
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
span.Heading8Char
	{mso-style-name:"Heading 8 Char";
	mso-style-link:"Heading 8";
	font-family:"Cambria","serif";
	color:#404040;}
span.Heading9Char
	{mso-style-name:"Heading 9 Char";
	mso-style-link:"Heading 9";
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
span.QuoteChar
	{mso-style-name:"Quote Char";
	mso-style-link:Quote;
	color:black;
	font-style:italic;}
.MsoPapDefault
	{margin-bottom:10.0pt;
	line-height:115%;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US link="#0B5294" vlink="#85DFD0">

<div class=Section1>

<div style='border:none;border-bottom:solid #0F6FC6 1.0pt;padding:0in 0in 4.0pt 0in'>

<p class=MsoTitle>Box2D v2.1.0 User Manual</p>

</div>

<p class=MsoSubtitle>Copyright © 2007-2010 Erin Catto</p>

<p class=MsoToc1><a href="#_Toc257704163">Chapter 1 Introduction<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>2</span></a></p>

<p class=MsoToc1><a href="#_Toc257704164">Chapter 2 Hello Box2D<span
style='color:windowtext;display:none;text-decoration:none'>.. </span><span
style='color:windowtext;display:none;text-decoration:none'>7</span></a></p>

<p class=MsoToc1><a href="#_Toc257704165">Chapter 3 Common<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>13</span></a></p>

<p class=MsoToc1><a href="#_Toc257704166">Chapter 4 Collision Module<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>15</span></a></p>

<p class=MsoToc1><a href="#_Toc257704167">Chapter 5 Dynamics Module<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>22</span></a></p>

<p class=MsoToc1><a href="#_Toc257704168">Chapter 6 Fixtures<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>23</span></a></p>

<p class=MsoToc1><a href="#_Toc257704169">Chapter 7 Bodies<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>26</span></a></p>

<p class=MsoToc1><a href="#_Toc257704170">Chapter 8 Joints<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>33</span></a></p>

<p class=MsoToc1><a href="#_Toc257704171">Chapter 9 Contacts<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>42</span></a></p>

<p class=MsoToc1><a href="#_Toc257704172">Chapter 10 World Class<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>48</span></a></p>

<p class=MsoToc1><a href="#_Toc257704173">Chapter 11 Loose Ends<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>54</span></a></p>

<p class=MsoToc1><a href="#_Toc257704174">Chapter 12 Debug Drawing<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>56</span></a></p>

<p class=MsoToc1><a href="#_Toc257704175">Chapter 13 References<span
style='color:windowtext;display:none;text-decoration:none'>. </span><span
style='color:windowtext;display:none;text-decoration:none'>58</span></a></p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704163"></a><a
name="_Toc253068169">Chapter 1 Introduction</a></h1>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068170">1.1 About</a></h2>

</div>

<p class=MsoNormal>Box2D is a 2D rigid body simulation library for games.
Programmers can use it in their games to make objects move in believable ways
and make the game world more interactive. From the game's point of view a
physics engine is just a system for procedural animation.</p>

<p class=MsoNormal>Box2D is written in portable C++. Most of the types defined
in the engine begin with the b2 prefix. Hopefully this is sufficient to avoid
name clashing with your game engine.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068171">1.2 Prerequisites</a></h2>

</div>

<p class=MsoNormal>In this manual I'll assume you are familiar with basic
physics concepts, such as mass, force, torque, and impulses. If not, please
first consult the many tutorials provided by Chris Hecker and David Baraff (Google
these names). You do not need to understand their tutorials in great detail,
but they do a good job of laying out the basic concepts that will help you use
Box2D.</p>

<p class=MsoNormal>Wikipedia is also an excellent source of physics and mathematics
knowledge. In some ways it is more useful than Google, because it has carefully
crafted content.</p>

<p class=MsoNormal>Box2D was created as part of a physics tutorial at the Game
Developer Conference. You can get these tutorials from the download section of
box2d.org.</p>

<p class=MsoNormal>Since Box2D is written in C++, you are expected to be
experienced in C++ programming. Box2D should not be your first C++ programming
project. You should be comfortable with compiling, linking, and debugging.</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Box2D should not be your
first C++ project. Please learn C++ programming, compiling, linking, and
debugging before working with Box2D. There are many resources for this on the
net.</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068172">1.3 About
this Manual</a></h2>

</div>

<p class=MsoNormal>This manual covers the majority of the Box2D API. However,
not every aspect is covered. You are encouraged to look at the testbed included
with Box2D to learn more. Also, the Box2D code base has comments formatted for
Doxygen, so it is easy to create a hyper-linked API document.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068173">1.4 Feedback
and Reporting Bugs</a></h2>

</div>

<p class=MsoNormal>If you have feedback about anything related to Box2D, please
leave a comment in the forum. This is also a great place for community
discussion.</p>

<p class=MsoNormal>Box2D issues are tracked using a Google code project. This
is a great way to track issues and ensures that your issue will not be lost in
the depths of the forums.</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuote style='margin-top:10.0pt;margin-right:0in;margin-bottom:
14.0pt;margin-left:0in;background:white'>File issues here: <a
href="http://code.google.com/p/box2d/">http://code.google.com/p/box2d/</a></p>

</div>

<p class=MsoNormal> You can help to ensure your issue gets fixed if you provide
sufficient detail. A testbed example that reproduces the problem is ideal.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068174">1.5 Core
Concepts</a></h2>

</div>

<p class=MsoNormal>Box2D works with several fundamental objects. We briefly
define these objects here and more details are given later in this document.</p>

<h4 style='margin-left:0in;text-indent:0in'><a name="_Toc253068175"></a><a
name="_Toc253068176">shape</a></h4>

<p class=MsoNormal>A 2D geometrical object, such as a circle or polygon.</p>

<h4 style='margin-left:0in;text-indent:0in'>rigid body</h4>

<p class=MsoNormal>A chunk of matter that is so strong that the distance between
any two bits of matter on the chunk is completely constant. They are hard like
a diamond. In the following discussion we use body interchangeably with rigid
body.</p>

<h4 style='margin-left:0in;text-indent:0in'><a name="_Toc253068177">fixture</a></h4>

<p class=MsoNormal>A fixture binds a shape to a body and adds material
properties such as density, friction, and restitution.</p>

<h4 style='margin-left:0in;text-indent:0in'><a name="_Toc253068178">constraint</a></h4>

<p class=MsoNormal>A constraint is a physical connection that removes degrees
of freedom from bodies. In 2D a body has 3 degrees of freedom (two translation
coordinates and one rotation coordinate). If we take a body and pin it to the
wall (like a pendulum) we have constrained the body to the wall. At this point
the body can only rotate about the pin, so the constraint has removed 2 degrees
of freedom.</p>

<h4 style='margin-left:0in;text-indent:0in'><a name="_Toc253068179">contact
constraint</a></h4>

<p class=MsoNormal>A special constraint designed to prevent penetration of
rigid bodies and to simulate friction and restitution. You do not create
contact constraints; they are created automatically by Box2D.</p>

<h4 style='margin-left:0in;text-indent:0in'><a name="_Toc253068180">joint</a></h4>

<p class=MsoNormal>This is a constraint used to hold two or more bodies
together. Box2D supports several joint types: revolute, prismatic, distance,
and more. Some joints may have limits and motors.</p>

<h4 style='margin-left:0in;text-indent:0in'><a name="_Toc253068181">joint limit</a></h4>

<p class=MsoNormal>A joint limit restricts the range of motion of a joint. For
example, the human elbow only allows a certain range of angles.</p>

<h4 style='margin-left:0in;text-indent:0in'><a name="_Toc253068182">joint motor</a></h4>

<p class=MsoNormal>A joint motor drives the motion of the connected bodies
according to the joint's degrees of freedom. For example, you can use a motor
to drive the rotation of an elbow.</p>

<h4 style='margin-left:0in;text-indent:0in'><a name="_Toc253068183">world</a></h4>

<p class=MsoNormal>A physics world is a collection of bodies, fixtures, and
constraints that interact together. Box2D supports the creation of multiple worlds,
but this is usually not necessary or desirable.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>1.6 Modules</h2>

</div>

<p class=MsoNormal>Box2D is composed of three modules: Common, Collision, and
Dynamics. The Common module has code for allocation, math, and settings. The
Collision module defines shapes, a broad-phase, and collision functions/queries.
Finally the Dynamics module provides the simulation world, bodies, fixtures,
and joints.</p>

<p class=MsoNormal><img border=0 width=231 height=244
src="manual_files/image001.png"></p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>1.7 Units</h2>

</div>

<p class=MsoNormal>Box2D works with floating point numbers, so some tolerances
have to be used to make Box2D perform well. These tolerances have been tuned to
work well with meters-kilogram-second (MKS) units. In particular, Box2D has
been tuned to work well with moving objects between 0.1 and 10 meters. So this
means objects between soup cans and buses in size should work well. Static
objects may be up to 50 meters without too much trouble.</p>

<p class=MsoNormal>Being a 2D physics engine, it is tempting to use pixels as
your units. Unfortunately this will lead to a poor simulation and possibly
weird behavior. An object of length 200 pixels would be seen by Box2D as the
size of a 45 story building. Imagine trying to simulate the movement of a
high-rise building with an engine that is tuned to simulate ragdolls and
barrels. It isn't pretty.</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Box2D is tuned for MKS
units. Keep the size of moving objects roughly between 0.1 and 10 meters.
You'll need to use some scaling system when you render your environment and
actors. The Box2D testbed does this by using an OpenGL viewport transform.</p>

</div>

<p class=MsoNormal>It is best to think of Box2D bodies as moving billboards
upon which you attach your artwork. The billboard may move in a unit system of
meters, but you can convert that to pixel coordinates with a simple scaling
factor. You can then use those pixel coordinates to place your sprites, etc.</p>

<p class=MsoNormal>Box2D uses radians for angles. The body rotation is stored
in radians and may grow unbounded. Consider normalizing the angle of your
bodies if the magnitude of the angle becomes too large (use b2Body::SetAngle).</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068193">1.8 Factories
and Definitions</a></h2>

</div>

<p class=MsoNormal>Memory management plays a central role in the design of the
Box2D API. So when you create a b2Bodyor a b2Joint, you need to call the
factory functions on b2World. You should never try to allocate these types in
another manner.</p>

<p class=MsoNormal>There are creation functions:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Body* b2World::CreateBody(const
b2BodyDef* def)</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Joint* b2World::CreateJoint(const
b2JointDef* def)</p>

</div>

<p class=MsoNormal>And there are corresponding destruction functions:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void b2World::DestroyBody(b2Body*
body)</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void b2World::DestroyJoint(b2Joint*
joint)</p>

</div>

<p class=MsoNormal>When you create a body or joint, you need to provide a
definition. These definitions contain all the information needed to build the
body or joint. By using this approach we can prevent construction errors, keep
the number of function parameters small, provide sensible defaults, and reduce
the number of accessors.</p>

<p class=MsoNormal>Since fixtures must be parented to a body, they are created
and destroyed using a factory method on b2Body:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Fixture*
b2Body::CreateFixture(const b2FixtureDef* def)</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void
b2Body::DestroyFixture(b2Fixture* fixture)</p>

</div>

<p class=MsoNormal>There is also shortcut to create a fixture directly from the
shape and density.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>b2Fixture* b2Body::CreateFixture(const
b2Shape* shape, float32 density)</p>

</div>

<p class=MsoNormal>Factories do not retain references to the definitions. So
you can create definitions on the stack and keep them in temporary resources.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068195">1.9 User
Data</a></h2>

</div>

<p class=MsoNormal>The b2Fixture, b2Body, and b2Joint classes allow you to
attach user data as a void pointer. This is handy when you are examining Box2D
data structures and you want to determine how they relate to the data
structures in your game engine.</p>

<p class=MsoNormal>For example, it is typical to attach an actor pointer to the
rigid body on that actor. This sets up a circular reference. If you have the
actor, you can get the body. If you have the body, you can get the actor.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>GameActor* actor =
GameCreateActor();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2BodyDef bodyDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.userData = actor;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>actor-&gt;body = box2Dworld-&gt;CreateBody(&amp;bodyDef);</p>

</div>

<p class=MsoNormal>Here are some examples of cases where you would need the
user data:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Applying damage to an actor using a collision result.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Playing a scripted event if the player is inside an axis-aligned box.</p>

<p class=MsoListParagraphCxSpLast style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Accessing a game structure when Box2D notifies you that a joint is going
to be destroyed.</p>

<p class=MsoNormal>Keep in mind that user data is optional and you can put
anything in it. However, you should be consistent. For example, if you want to
store an actor pointer on one body, you should keep an actor pointer on all
bodies. Don't store an actor pointer on one body, and a foo pointer on another
body. Casting an actor pointer to a foo pointer may lead to a crash.</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704164"></a><a
name="_Toc253068184">Chapter 2 Hello Box2D</a></h1>

</div>

<p class=MsoNormal>In the distribution of Box2D is a Hello World project. The
program creates a large ground box and a small dynamic box. This code does not
contain any graphics. All you will see is text output in the console of the
box's position over time.</p>

<p class=MsoNormal>This is a good example of how to get up and running with
Box2D.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068185">2.1 Creating
a World</a></h2>

</div>

<p class=MsoNormal>Every Box2D program begins with the creation of a b2World
object. b2World is the physics hub that manages memory, objects, and
simulation. You can allocate the physics world on the stack, heap, or data
section. The decision is up to you.</p>

<p class=MsoNormal>It is easy to create a Box2D world. First, we define the
gravity vector. Also we tell the world to allow bodies to sleep when they come
to rest. A sleeping body doesn't require any simulation.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 gravity(0.0f, -10.0f);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool doSleep = true;</p>

</div>

<p class=MsoNormal>Now we create the world object. Note that we are creating
the world on the stack, so the world must remain in scope.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>b2World world(gravity, doSleep);</p>

</div>

<p class=MsoNormal>So now we have our physics world, let's start adding some
stuff to it.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068186">2.2 Creating
a Ground Box</a></h2>

</div>

<p class=MsoNormal>Bodies are built using the following steps:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:.75in;text-indent:-.5in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Define a body with a position, damping, etc.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Use the world object to create the body.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Define fixtures with a shape, friction, density, etc.</p>

<p class=MsoListParagraphCxSpLast style='margin-left:.75in;text-indent:-.5in'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Create fixtures on the body.</p>

<p class=MsoNormal>For step 1 we create the ground body. For this we need a
body definition. With the body definition we specify the initial position of
the ground body.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2BodyDef groundBodyDef;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>groundBodyDef.position.Set(0.0f,
-10.0f);</p>

</div>

<p class=MsoNormal>For step 2 the body definition is passed to the world object
to create the ground body. The world object does not keep a reference to the
body definition. The ground body is created as a static body. Static bodies
don't collide with other static bodies and are immovable. Box2D determines that
a body is static when it has zero mass. Bodies have zero mass by default;
therefore they are static by default.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>b2Body* groundBody =
world.CreateBody(&amp;groundBodyDef);</p>

</div>

<p class=MsoNormal>For step 3 we create a ground polygon. We use the SetAsBox
shortcut to form the ground polygon into a box shape, with the box centered on
the origin of the parent body.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2PolygonShape groundBox;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>groundBox.SetAsBox(50.0f, 10.0f);</p>

</div>

<p class=MsoNormal>The SetAsBox function takes the half-width and half-height
(extents). So in this case the ground box is 100 units wide (x-axis) and 20
units tall (y-axis). Box2D is tuned for meters, kilograms, and seconds. So you
can consider the extents to be in meters. Box2D generally works best when
objects are the size of typical real world objects. For example, a barrel is
about 1 meter tall. Due to the limitations of floating point arithmetic, using
Box2D to model the movement of glaciers or dust particles is not a good idea.</p>

<p class=MsoNormal>We finish the ground body in step 4 by creating the shape
fixture. For this step we have a shortcut. We do not have a need to alter the
default fixture material properties, so can pass the shape directly to the body
without creating a fixture definition. Later we will see how to use a fixture
definition for customized material properties.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>groundBody-&gt;CreateFixture(&amp;groundBox);</p>

</div>

<p class=MsoNormal>Box2D does not keep a reference to the shape. It clones the
data into a new b2Shape object.</p>

<p class=MsoNormal>Note that every fixture must have a parent body, even
fixtures that are static. However, you can attach all static fixtures to a
single static body. This need for static bodies is done to make the Box2D code
more uniform internally, reducing the number of potential bugs.</p>

<p class=MsoNormal>You might notice a pattern here. Most Box2D types are
prefixed with b2. This is done to reduce the chance for naming conflicts with
your code.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068187">2.3 Creating
a Dynamic Body</a></h2>

</div>

<p class=MsoNormal>So now we have a ground body. We can use the same technique
to create a dynamic body. The main difference, besides dimensions, is that we
must establish the dynamic body's mass properties.</p>

<p class=MsoNormal>First we create the body using CreateBody. By default bodies
are static, so we should set the b2BodyType at construction time to make the
body dynamic.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2BodyDef bodyDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.type = b2_dynamicBody;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.position.Set(0.0f, 4.0f);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Body* body =
world.CreateBody(&amp;bodyDef);</p>

</div>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Caution</p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>You must set the body
type to b2_dynamicBody if you want the body to move in response to forces.</p>

</div>

<p class=MsoNormal>Next we create and attach a polygon shape using a fixture
definition. First we create a box shape:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2PolygonShape dynamicBox;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>dynamicBox.SetAsBox(1.0f, 1.0f);</p>

</div>

<p class=MsoNormal>Next we create a fixture definition using the box. Notice
that we set density to 1. The default density is zero. Also, the friction on
the shape is set to 0.3. </p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2FixtureDef fixtureDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>fixtureDef.shape = &amp;dynamicBox;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>fixtureDef.density = 1.0f;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>fixtureDef.friction = 0.3f;</p>

</div>

<p class=MsoNormal>Using the fixture definition we can now create the fixture.
This automatically updates the mass of the body. You can add as many fixtures
as you like to a body. Each one contributes to the total mass.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>body-&gt;CreateFixture(&amp;fixtureDef);</p>

</div>

<p class=MsoNormal>That's it for initialization. We are now ready to begin
simulating.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068188">2.4 Simulating
the World (of Box2D)</a></h2>

</div>

<p class=MsoNormal>So we have initialized the ground box and a dynamic box. Now
we are ready to set Newton loose to do his thing. We just have a couple more
issues to consider.</p>

<p class=MsoNormal>Box2D uses a computational algorithm called an integrator.
Integrators simulate the physics equations at discrete points of time. This
goes along with the traditional game loop where we essentially have a flip book
of movement on the screen. So we need to pick a time step for Box2D. Generally
physics engines for games like a time step at least as fast as 60Hz or 1/60
seconds. You can get away with larger time steps, but you will have to be more
careful about setting up the definitions for your world. We also don't like the
time step to change much. A variable time step produces variable results, which
makes it difficult to debug. So don't tie the time step to your frame rate
(unless you really, really have to). Without further ado, here is the time
step.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>float32 timeStep = 1.0f / 60.0f;</p>

</div>

<p class=MsoNormal>In addition to the integrator, Box2D also uses a larger bit
of code called a constraint solver. The constraint solver solves all the
constraints in the simulation, one at a time. A single constraint can be solved
perfectly. However, when we solve one constraint, we slightly disrupt other
constraints. To get a good solution, we need to iterate over all constraints a
number of times.</p>

<p class=MsoNormal>There are two phases in the constraint solver: a velocity
phase and a position phase. In the velocity phase the solver computes the
impulses necessary for the bodies to move correctly. In the position phase the
solver adjusts the positions of the bodies to reduce overlap and joint
detachment. Each phase has its own iteration count. In addition, the position
phase may exit iterations early if the errors are small.</p>

<p class=MsoNormal>The suggested iteration count for Box2D is 10 for both
velocity and position. You can tune this number to your liking, just keep in
mind that this has a trade-off between speed and accuracy. Using fewer
iterations increases performance but accuracy suffers. Likewise, using more
iterations decreases performance but improves the quality of your simulation.
For this simple example, we don't need much iteration. Here are our chosen
iteration counts.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>int32 velocityIterations = 6;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>int32 positionIterations = 2;</p>

</div>

<p class=MsoNormal>Note that the time step and the iteration count are
completely unrelated. An iteration is not a sub-step. One iteration is a single
pass over all the constraints within a time step. You can have multiple passes
over the constraints within a single time step.</p>

<p class=MsoNormal>We are now ready to begin the simulation loop. In your game
the simulation loop can be merged with your game loop. In each pass through
your game loop you call b2World::Step. Just one call is usually enough,
depending on your frame rate and your physics time step. After stepping, you should
call b2World::ClearForces to clear any forces you applied to the bodies.</p>

<p class=MsoNormal>The Hello World program was designed to be dead simple, so
it has no graphical output. Rather than being utterly boring by producing no
output, the code prints out the position and rotation of the dynamic body. Here
is the simulation loop that simulates 60 time steps for a total of 1 second of
simulated time.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>for (int32 i = 0; i &lt; 60; ++i)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    world.Step(timeStep,
velocityIterations, positionIterations);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    world.ClearForces();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Vec2 position =
body-&gt;GetPosition();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    float32 angle =
body-&gt;GetAngle();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    printf(&quot;%4.2f %4.2f
%4.2f\n&quot;, position.x, position.y, angle);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>The output shows the box falling and landing on the ground
box. Your output should look like this:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>0.00 4.00 0.00</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>0.00 3.99 0.00</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>0.00 3.98 0.00</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>...</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>0.00 1.25 0.00</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>0.00 1.13 0.00</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>0.00 1.01 0.00</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068189">2.5 Cleanup</a></h2>

</div>

<p class=MsoNormal>When a world leaves scope or is deleted by calling delete on
a pointer, all the memory reserved for bodies, fixtures, and joints is freed.
This is done to make your life easier. However, you will need to nullify any
body, fixture, or joint pointers you have because they will become invalid.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068190">2.6 The
Testbed</a></h2>

</div>

<p class=MsoNormal>Once you have conquered the HelloWorld example, you should
start looking at Box2D's testbed. The testbed is a unit-testing framework and
demo environment. Here are some of the features:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Camera with pan and zoom.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Mouse picking of shapes attached to dynamic bodies.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Extensible set of tests.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>GUI for selecting tests, parameter tuning, and debug drawing options.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Pause and single step simulation.</p>

<p class=MsoListParagraphCxSpLast style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Text rendering.</p>

<p class=MsoNormal><img border=0 width=559 height=501 id="Picture 0"
src="manual_files/image002.gif" alt=testbed.gif></p>

<p class=MsoNormal>The testbed has many examples of Box2D usage in the test
cases and the framework itself. I encourage you to explore and tinker with the
testbed as you learn Box2D.</p>

<p class=MsoNormal>Note: the testbed is written using freeglut and GLUI. The
testbed is not part of the Box2D library. The Box2D library is agnostic about
rendering. As shown by the HelloWorld example, you don't need a renderer to use
Box2D.</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704165">Chapter 3 Common</a></h1>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>3.1 About</h2>

</div>

<p class=MsoNormal>The Common module contains settings, memory management, and
vector math.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>3.2 Settings</h2>

</div>

<p class=MsoNormal>The header b2Settings.h contains:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Types such as int32 and float32</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Constants</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Allocation wrappers</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The version number</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Friction and restitution mixing functions</p>

<h3 style='margin-left:0in;text-indent:0in'>Types</h3>

<p class=MsoNormal>Box2D defines various types such as float32, int8, etc. to
make it easy to determine the size of structures.</p>

<h3 style='margin-left:0in;text-indent:0in'>Constants</h3>

<p class=MsoNormal>Box2D defines several constants. These are all documented in
b2Settings.h. Normally you do not need to adjust these constants.</p>

<p class=MsoNormal>Box2D uses floating point math for collision and simulation.
Due to round-off error some numerical tolerances are defined. Some tolerances
are absolute and some are relative.  Absolute tolerances use MKS units.</p>

<h3 style='margin-left:0in;text-indent:0in'>Allocation wrappers</h3>

<p class=MsoNormal>The settings file defines b2Alloc and b2Free for large
allocations. You may forward these calls to your own memory management system.</p>

<h3 style='margin-left:0in;text-indent:0in'>Version</h3>

<p class=MsoNormal>The b2Version structure holds the current version so you can
query this at run-time.</p>

<h3 style='margin-left:0in;text-indent:0in'>Friction and Restitution Mixing</h3>

<p class=MsoNormal>These are placed in the settings file in case you need to
customize them for your application.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'><a name="_Toc253068192">3.3 Memory
Management</a></h2>

</div>

<p class=MsoNormal>A large number of the decisions about the design of Box2D
were based on the need for quick and efficient use of memory. In this section I
will discuss how and why Box2D allocates memory.</p>

<p class=MsoNormal>Box2D tends to allocate a large number of small objects
(around 50-300 bytes). Using the system heap through malloc or new for small
objects is inefficient and can cause fragmentation. Many of these small objects
may have a short life span, such as contacts, but can persist for several time
steps. So we need an allocator that can efficiently provide heap memory for
these objects.</p>

<p class=MsoNormal>Box2D's solution is to use a small object allocator (SOA)
called b2BlockAllocator. The SOA keeps a number of growable pools of varying
sizes. When a request is made for memory, the SOA returns a block of memory
that best fits the requested size. When a block is freed, it is returned to the
pool. Both of these operations are fast and cause little heap traffic.</p>

<p class=MsoNormal>Since Box2D uses a SOA, you should never new or malloc a
body, fixture, or joint. You do have to allocate a b2World. The b2World class
provides factories for you to create bodies, fixtures, and joints. This allows
Box2D to use the SOA and hide the gory details from you. Never, ever, call
delete or free on a body, fixture, or joint.</p>

<p class=MsoNormal>While executing a time step, Box2D needs some temporary
workspace memory. For this, it uses a stack allocator called b2StackAllocator
to avoid per-step heap allocations. You don't need to interact with the stack
allocator, but it's good to know it's there.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>3.4 Math</h2>

</div>

<p class=MsoNormal>Box2D includes a simple small vector and matrix module. This
has been designed to suit the internal needs of Box2D and the API. All the
members are exposed, so you may use them freely in your application.</p>

<p class=MsoNormal>The math library is kept simple to make Box2D easy to port
and maintain.</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704166">Chapter 4 Collision
Module</a></h1>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.1 About</h2>

</div>

<p class=MsoNormal>The Collision module contains shapes and functions that
operate on them. The module also contains a dynamic tree and broad-phase to
acceleration collision processing of large systems. </p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.2 Shapes</h2>

</div>

<p class=MsoNormal>Shapes describe collision geometry and may be used
independently of physics simulation. You may perform several operations with
shapes.</p>

<p class=MsoNormal>Box2D shapes implement the b2Shape base class. The base
class defines functions to:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Test a point for overlap with the shape.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Perform a ray cast against the shape.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Compute the shape's AABB.</p>

<p class=MsoListParagraphCxSpLast style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Compute the mass properties of the shape.</p>

<p class=MsoNormal>In addition, each shape has a type member and a radius. The
radius even applies to polygons, as discussed below.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.3 Circle Shapes</h2>

</div>

<p class=MsoNormal>Circle shapes have a position and radius.</p>

<p class=MsoNormal>Circles are solid. You cannot make a hollow circle. However,
you can create chains of line segments using polygon shapes.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2CircleShape circle;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>circle.m_p.Set(1.0f, 2.0f, 3.0f);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>circle.m_radius = 0.5f;</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.4 Polygon Shapes</h2>

</div>

<p class=MsoNormal>Polygon shapes are solid convex polygons. A polygon is
convex when all line segments connecting two points in the interior do not
cross any edge of the polygon. Polygons are solid and never hollow. However,
you can create line segments using 2 point polygons.</p>

<p class=MsoNormal><img border=0 width=223 height=125
src="manual_files/image003.gif" alt="convex_concave.gif"></p>

<p class=MsoNormal>You must create polygons with a counter clockwise winding
(CCW). We must be careful because the notion of CCW is with respect to a
right-handed coordinate system with the z-axis pointing out of the plane. This
might turn out to be clockwise on your screen, depending on your coordinate
system conventions.</p>

<p class=MsoNormal><img border=0 width=370 height=188
src="manual_files/image004.png"></p>

<p class=MsoNormal>The polygon members are public, but you should use
initialization functions to create a polygon. The initialization functions
create normal vectors and perform validation.</p>

<p class=MsoNormal>You can create a polygon shape by passing in a vertex array.
The maximal size of the array is controlled by b2_maxPolygonVertices which has
a default value of 8. This is sufficient to describe most convex polygons.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// This defines a triangle in CCW
order.</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 vertices[3];</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>vertices[0].Set(0.0f, 0.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>vertices[1].Set(1.0f, 0.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>vertices[2].Set(0.0f, 1.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>int32 count = 3;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2PolygonShape polygon;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>polygon.Set(vertices, count);</p>

</div>

<p class=MsoNormal>The polygon shape has some custom initialization functions
to create boxes and edges (line segments).</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetAsBox(float32 hx, float32
hy);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetAsBox(float32 hx, float32
hy, const b2Vec2&amp; center, float32 angle);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetAsEdge(const b2Vec2&amp; v1,
const b2Vec2&amp; v2);</p>

</div>

<p class=MsoNormal>Polygons inherit a radius from b2Shape. The radius creates a
skin around the polygon. The skin is used in stacking scenarios to keep
polygons slightly separated. This allows continuous collision to work against
the core polygon.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.5 Shape Point Test</h2>

</div>

<p class=MsoNormal>You can test a point for overlap with a shape. You provide a
transform for the shape and a world point.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Transfrom transform;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>transform.SetIdentity();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 point(5.0f, 2.0f);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool hit =
shape-&gt;TestPoint(transform, point);</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.6 Shape Ray Cast</h2>

</div>

<p class=MsoNormal>You can cast a ray at a shape to get the point of first intersection
and normal vector. No hit will register if the ray starts inside the shape.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Transfrom transform;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>transform.SetIdentity();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2RayCastInput input;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>input.p1.Set(0.0f, 0.0f, 0.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>input.p2.Set(1.0f, 0.0f, 0.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>input.maxFraction = 1.0f;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2RayCastOutput output;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool hit = shape-&gt;RayCast(&amp;output,
input, transform);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>if (hit)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  b2Vec2 hitPoint = input.p1 +
output.fraction * (input.p2 – input.p1);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  …</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.7 Bilateral Functions</h2>

</div>

<p class=MsoNormal>The Collision module contains bilateral functions that take
a pair of shapes and compute some results. These include:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Contact manifolds</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Distance</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Time of impact</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.8 Contact Manifolds</h2>

</div>

<p class=MsoNormal>Box2D has functions to compute contact points for
overlapping shapes. If we consider circle-circle or circle-polygon, we can only
get one contact point and normal. In the case of polygon-polygon we can get two
points. These points share the same normal vector so Box2D groups them into a
manifold structure. The contact solver takes advantage of this to improve
stacking stability.</p>

<p class=MsoNormal><img border=0 width=303 height=212
src="manual_files/image005.png"></p>

<p class=MsoNormal>Normally you don’t need to compute contact manifolds
directly, however you will likely use the results produced in the simulation.</p>

<p class=MsoNormal>The b2Manifold structure holds a normal vector and up to two
contact points. The normal and points are held in local coordinates. As a
convenience for the contact solver, each point stores the normal and tangential
(friction) impulses.</p>

<p class=MsoNormal>The b2WorldManifold structure can be used to generate the
world coordinates of the contact normal and points. You need to provide a
b2Manifold and the shape transforms and radii.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2WorldManifold worldManifold;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>worldManifold.Initialize(&amp;manifold,
transformA, shapeA.m_radius,</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>                         transformB,
shapeB.m_radius);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>for (int32 i = 0; i &lt;
manifold.pointCount; ++i)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  b2Vec2 point =
worldManifold.points[i];</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  …</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>During simulation shapes may move and the manifolds may
change. Points may be added or removed. You can detect this using
b2GetPointStates.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2PointState state1[2], state2[2];</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2GetPointStates(state1, state2,
&amp;manifold1, &amp;manifold2);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>if (state1[0] == b2_removeState)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  // process event</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.9 Distance</h2>

</div>

<p class=MsoNormal>The b2Distance function can be used to compute the distance
between two shapes.  The distance function needs both shapes to be converted
into a b2DistanceProxy. There is also some caching used to warm start the
distance function for repeated calls. You can see the details in b2Distance.h.</p>

<p class=MsoNormal><img border=0 width=289 height=143
src="manual_files/image006.png"></p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.10 Time of Impact</h2>

</div>

<p class=MsoNormal>If two shapes are moving fast, they may <i>tunnel</i>
through each other in a single time step. </p>

<p class=MsoNormal><img border=0 width=250 height=142
src="manual_files/image007.png"></p>

<p class=MsoNormal>The b2TimeOfImpact is used to determine the time when two
moving shapes collide. This is called the <i>time of impact </i>(TOI). The main
purpose of b2TimeOfImpact is for tunnel prevention. In particular, it is
designed to prevent moving objects from tunneling outside of static level
geometry.</p>

<p class=MsoNormal>This function accounts for rotation and translation of both
shapes, however if the rotations are large enough, then the function may miss a
collision. However the function will still report a non-overlapped time and
will capture all translational collisions.</p>

<p class=MsoNormal>The time of impact function identities an initial separating
axis and ensures the shapes do not cross on that axis. This will miss
collisions that are clear at the final positions. While this approach may miss
some collisions, it is very fast and adequate for tunnel prevention. </p>

<p class=MsoNormal><img border=0 width=317 height=180 id="Picture 7"
src="manual_files/image008.png"></p>

<p class=MsoNormal><img border=0 width=317 height=185 id="Picture 6"
src="manual_files/image009.png"></p>

<p class=MsoNormal>It is difficult to put a restriction on the rotation magnitude.
There may be cases where collisions are missed for small rotations. Normally,
these missed rotational collisions should not harm game play.</p>

<p class=MsoNormal>The function requires two shapes (converted to
b2DistanceProxy) and two b2Sweep structures. The sweep structure defines the
initial and final transforms of the shapes.</p>

<p class=MsoNormal>You can use fixed rotations to perform a <i>shape cast</i>.
In this case, the time of impact function will not miss any collisions.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.11 Dynamic Tree</h2>

</div>

<p class=MsoNormal>The b2DynamicTree class is used by Box2D to organize large
numbers of shapes efficiently. The class does not know about shapes. Instead it
operates on axis-aligned bounding boxes (AABBs) with user data pointers.</p>

<p class=MsoNormal>The dynamic tree is a hierarchical AABB tree. Each internal
node in the tree can has two children. A leaf node is a single user AABB.</p>

<p class=MsoNormal>The tree structure allows for efficient ray casts and region
queries. For example, you may have hundreds of shapes in your scene. You could
perform a ray cast against the scene in a brute force manner by ray casting
each shape. This would be inefficient because it does not take advantage of shapes
being spread out. Instead, you can maintain a dynamic tree and perform ray
casts against the tree. This traverses the ray through the tree skipping large
numbers of shapes.</p>

<p class=MsoNormal>A region query uses the tree to find all leaf AABBs that
overlap a query AABB. This is faster than a brute force approach because many
shapes can be skipped.</p>

<p class=MsoNormal><img border=0 width=265 height=266 id="Picture 8"
src="manual_files/image010.png"></p>

<p class=MsoNormal><img border=0 width=246 height=224 id="Picture 9"
src="manual_files/image011.png"></p>

<p class=MsoNormal>Normally you will not use the dynamic tree directly. Rather
you will go through the b2World class for ray casts and region queries. If you
do plan to create your own dynamic tree, you can learn how to use it by looking
at how Box2D uses it.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>4.12 Broad-phase</h2>

</div>

<p class=MsoNormal>Collision processing in a physics step can be divided into
narrow-phase and broad-phase. In the narrow-phase we compute contact points
between pairs of shapes. Imagine we have N shapes. Using brute force, we would
need to perform the narrow-phase for N*N/2 pairs.</p>

<p class=MsoNormal>The b2BroadPhase class reduces this load by using a dynamic
tree for pair management. This greatly reduces the number of narrow-phase
calls.</p>

<p class=MsoNormal>Normally you do not interact with the broad-phase directly.
Instead, Box2D creates and manages a broad-phase internally. Also, b2BroadPhase
is designed with Box2D’s simulation loop in mind, so it is likely not suited
for other use cases.</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704167">Chapter 5 Dynamics
Module</a></h1>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>5.1 Overview</h2>

</div>

<p class=MsoNormal>The Dynamics module is the most complex part of Box2D and is
the part you likely interact with the most. The Dynamics module sits on top of
the Common and Collision modules, so you should be familiar with those by now.</p>

<p class=MsoNormal>The Dynamics module contains:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>shape fixture class</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>rigid body class</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>contact class</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>joint classes</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>world class</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>listener classes</p>

<p class=MsoNormal>There are many dependencies between these classes so it is difficult
to describe one class without referring to another. In the following, you may
see some references to classes that have not been described yet. Therefore, you
may want to quickly skim this chapter before reading it closely.</p>

<p class=MsoNormal>The dynamics module is covered in the following chapters.</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704168">Chapter 6 Fixtures</a></h1>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>6.1 About</h2>

</div>

<p class=MsoNormal>Recall that shapes don’t know about bodies and may be used
independently. Therefore Box2D provides the b2Fixture class to attach shapes to
bodies. Fixtures hold the following:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>a single shape</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>density, friction, and restitution</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>collision filtering flags</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>back pointer to parent body</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>user data</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>sensor flag</p>

<p class=MsoNormal>These are described in the following sections.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>6.2 Fixture Creation</h2>

</div>

<p class=MsoNormal>Fixtures are created by initializing a fixture definition
and then passing the definition to the parent body.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2FixtureDef fixtureDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>fixtureDef.shape = &amp;myShape;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>fixtureDef.density = 1.0f;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Fixture* myFixture = myBody-&gt;CreateFixture(&amp;fixtureDef);</p>

</div>

<p class=MsoNormal>This creates the fixture and attaches it to the body. You do
not need to store the fixture pointer since the fixture will automatically be
destroyed when the parent body is destroyed. You can create multiple fixtures
on a single body.</p>

<p class=MsoNormal>You can destroy a fixture on the parent body. You may do
this to model a breakable object. Otherwise you can just leave the fixture
alone and let the body destruction take care of destroying the attached fixtures.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>myBody-&gt;DestroyFixture(myFixture);</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>Density</h3>

<p class=MsoNormal> The fixture density is used to compute the mass properties of
the parent body. The density can be zero or positive. You should generally use
similar densities for all your fixtures. This will improve stacking stability.</p>

<p class=MsoNormal>The mass of a body is automatically adjusted when you </p>

<h3 style='margin-left:0in;text-indent:0in'>Friction</h3>

<p class=MsoNormal>Friction is used to make objects slide along each other
realistically. Box2D supports static and dynamic friction, but uses the same
parameter for both. Friction is simulated accurately in Box2D and the friction
strength is proportional to the normal force (this is called Coulomb friction).
The friction parameter is usually set between 0 and 1, but can be any
non-negative value. A friction value of 0 turns off friction and a value of 1
makes the friction strong. When the friction force is computed between two
shapes, Box2D must combine the friction parameters of the two parent fixtures.
This is done with the geometric mean:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 friction;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>friction = sqrtf(shape1-&gt;friction
* shape2-&gt;friction);</p>

</div>

<p class=MsoNormal>So if one fixture has zero friction then the contact will
have zero friction.</p>

<h3 style='margin-left:0in;text-indent:0in'>Restitution</h3>

<p class=MsoNormal>Restitution is used to make objects bounce. The restitution
value is usually set to be between 0 and 1. Consider dropping a ball on a
table. A value of zero means the ball won't bounce. This is called an inelastic
collision. A value of one means the ball's velocity will be exactly reflected.
This is called a perfectly elastic collision. Restitution is combined using the
following formula.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 restitution;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>restitution = b2Max(shape1-&gt;restitution,
shape2-&gt;restitution);</p>

</div>

<p class=MsoNormal>Fixtures carry collision filtering information to let you
prevent collisions between certain game objects.</p>

<p class=MsoNormal>When a shape develops multiple contacts, restitution is
simulated approximately. This is because Box2D uses an iterative solver. Box2D
also uses inelastic collisions when the collision velocity is small. This is
done to prevent jitter.</p>

<h3 style='margin-left:0in;text-indent:0in'>Filtering</h3>

<p class=MsoNormal>Collision filtering is a system for preventing collision
between fixtures. For example, say you make a character that rides a bicycle.
You want the bicycle to collide with the terrain and the character to collide
with the terrain, but you don't want the character to collide with the bicycle
(because they must overlap). Box2D supports such collision filtering using
categories and groups.</p>

<p class=MsoNormal>Box2D supports 16 collision categories. For each fixture you
can specify which category it belongs to. You also specify what other
categories this fixture can collide with. For example, you could specify in a
multiplayer game that all players don't collide with each other and monsters
don't collide with each other, but players and monsters should collide. This is
done with masking bits. For example:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>playerFixtureDef.filter.categoryBits
= 0x0002;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>monsterFixtureDef.filter.categoryBits
= 0x0004;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>playerFixtureDef.filter.maskBits =
0x0004;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>monsterFixtureDef.filter.maskBits =
0x0002;</p>

</div>

<p class=MsoNormal>Collision groups let you specify an integral group index.
You can have all fixtures with the same group index always collide (positive
index) or never collide (negative index). Group indices are usually used for
things that are somehow related, like the parts of a bicycle. In the following
example, fixture1 and fixture2 always collide, but fixture3 and fixture4 never
collide.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>fixture1Def.filter.groupIndex = 2;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>fixture2Def.filter.groupIndex = 2;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>fixture3Def.filter.groupIndex = -8;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>fixture4Def.filter.groupIndex = -8;</p>

</div>

<p class=MsoNormal>Collisions between fixtures of different group indices are
filtered according the category and mask bits. In other words, group filtering
has higher precedence than category filtering.</p>

<p class=MsoNormal>Note that additional collision filtering occurs in Box2D.
Here is a list:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>A fixture on a static body never collides with a fixture on
another static body.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Fixtures on the same body never collide with each other.</p>

<p class=MsoListParagraphCxSpLast style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>You can optionally enable/disable collision between fixtures on
bodies connected by a joint.</p>

<p class=MsoNormal>Sometimes you might need to change collision filtering after
a fixture has already been created. You can get and set the b2Filter structure
on an existing fixture using b2Fixture::GetFilterData and b2Fixture::SetFilterData.
Note that changing the filter data will not add or remove contacts until the
next time step (see the World class).</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>6.3 Sensors</h2>

</div>

<p class=MsoNormal>Sometimes game logic needs to know when two fixtures overlap
yet there should be no collision response. This is done by using sensors. A
sensor is a fixture that detects collision but does not produce a response.</p>

<p class=MsoNormal>You can flag any fixture as being a sensor. Sensors may be
static or dynamic. Remember that you may have multiple fixtures per body and
you can have any mix of sensors and solid fixtures.</p>

<p class=MsoNormal>Sensors do not generate contact points. There are two ways
to get the state of a sensor:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b2Contact::IsTouching</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>b2ContactListener::BeginContact
and EndContact</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704169">Chapter 7 Bodies</a></h1>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>7.1 About</h2>

</div>

<p class=MsoNormal>Bodies have position and velocity. You can apply forces,
torques, and impulses to bodies. Bodies can be static, kinematic, or dynamic.
Here are the body type definitions:</p>

<h4 style='margin-left:0in;text-indent:0in'>b2_staticBody</h4>

<p class=MsoNormal>A static body has does not move under simulation and behaves
as if it has infinite mass. Internally, Box2D stores zero for the mass and the
inverse mass. Static bodies can be moved manually by the user. A static body
has zero velocity. Static bodies do not collide with other static or kinematic
bodies.</p>

<h4 style='margin-left:0in;text-indent:0in'>b2_kinematicBody</h4>

<p class=MsoNormal>A kinematic body moves under simulation according to its
velocity. Kinematic bodies do not respond to forces. They can be moved manually
by the user, but normally a kinematic body is moved by setting its velocity. A
kinematic body behaves as if it has infinite mass, however, Box2D stores zero
for the mass and the inverse mass. Kinematic bodies do not collide with other
static or kinematic bodies.</p>

<h4 style='margin-left:0in;text-indent:0in'>b2_dynamicBody</h4>

<p class=MsoNormal>A dynamic body is fully simulated. They can be moved
manually by the user, but normally they move according to forces. A dynamic
body can collide with all body types. A dynamic body always has finite,
non-zero mass. If you try to set the mass of a dynamic body to zero, it will
automatically acquire a mass of one kilogram.</p>

<p class=MsoNormal>Bodies are the backbone for fixtures. Bodies carry fixtures
and move them around in the world. Bodies are always rigid bodies in Box2D.
That means that two fixtures attached to the same rigid body never move
relative to each other.</p>

<p class=MsoNormal>Fixtures have collision geometry and density. Normally,
bodies acquire their mass properties from the fixtures. However, you can
override the mass properties after a body is constructed. This is discussed
below.</p>

<p class=MsoNormal>You usually keep pointers to all the bodies you create. This
way you can query the body positions to update the positions of your graphical
entities. You should also keep body pointers so you can destroy them when you
are done with them.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>7.2 Body Definition</h2>

</div>

<p class=MsoNormal>Before a body is created you must create a body definition
(b2BodyDef). The body definition holds the data needed to create and initialize
a body.</p>

<p class=MsoNormal>Box2D copies the data out of the body definition; it does
not keep a pointer to the body definition. This means you can recycle a body
definition to create multiple bodies.</p>

<p class=MsoNormal>Let’s go over some of the key members of the body
definition.</p>

<h3 style='margin-left:0in;text-indent:0in'>Body Type</h3>

<p class=MsoNormal>As discussed at the beginning of this chapter, there are
three different body types: static, kinematic, and dynamic. You should
establish the body type at creation because changing the body type later is
expensive.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>bodyDef.type = b2_dynamicBody;</p>

</div>

<p class=MsoNormal>Setting the body type is mandatory.</p>

<h3 style='margin-left:0in;text-indent:0in'>Position and Angle</h3>

<p class=MsoNormal>The body definition gives you the chance to initialize the
position of the body on creation. This has far better performance than creating
the body at the world origin and then moving the body.</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Do not create a body at
the origin and then move it. If you create several bodies at the origin, then
performance will suffer.</p>

</div>

<p class=MsoNormal>A body has two main points of interest. The first point is
the body's origin. Fixtures and joints are attached relative to the body's
origin. The second point of interest is the center of mass. The center of mass
is determined from mass distribution of the attached shapes or is explicitly
set with b2MassData. Much of Box2D's internal computations use the center of
mass position. For example b2Body stores the linear velocity for the center of
mass.</p>

<p class=MsoNormal>When you are building the body definition, you may not know
where the center of mass is located. Therefore you specify the position of the
body's origin. You may also specify the body's angle in radians, which is not
affected by the position of the center of mass. If you later change the mass
properties of the body, then the center of mass may move on the body, but the
origin position does not change and the attached shapes and joints do not move.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.position.Set(0.0f, 2.0f);  
// the body's origin position.</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.angle = 0.25f * b2_pi;     
// the body's angle in radians.</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>Damping</h3>

<p class=MsoNormal>Damping is used to reduce the world velocity of bodies.
Damping is different than friction because friction only occurs with contact.
Damping is not a replacement for friction and the two effects should be used
together.</p>

<p class=MsoNormal>Damping parameters should be between 0 and infinity, with 0
meaning no damping, and infinity meaning full damping. Normally you will use a
damping value between 0 and 0.1. I generally do not use linear damping because
it makes bodies look floaty.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.linearDamping = 0.0f;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.angularDamping = 0.01f;</p>

</div>

<p class=MsoNormal>Damping is approximated for stability and performance. At
small damping values the damping effect is mostly independent of the time step.
At larger damping values, the damping effect will vary with the time step. This
is not an issue if you use a fixed time step (recommended).</p>

<h3 style='margin-left:0in;text-indent:0in'>Sleep Parameters</h3>

<p class=MsoNormal>What does sleep mean? Well it is expensive to simulate
bodies, so the less we have to simulate the better. When a body comes to rest
we would like to stop simulating it.</p>

<p class=MsoNormal>When Box2D determines that a body (or group of bodies) has
come to rest, the body enters a sleep state which has very little CPU overhead.
If a body is awake and collides with a sleeping body, then the sleeping body
wakes up. Bodies will also wake up if a joint or contact attached to them is
destroyed. You can also wake a body manually.</p>

<p class=MsoNormal>The body definition lets you specify whether a body can
sleep and whether a body is created sleeping.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.allowSleep = true;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.awake = true;</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>Fixed Rotation</h3>

<p class=MsoNormal>You may want a rigid body, such as a character, to have a fixed
rotation. Such a body should not rotate, even under load. You can use the fixed
rotation setting to achieve this:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>bodyDef.fixedRotation = true;</p>

</div>

<p class=MsoNormal>The fixed rotation flag causes the rotational inertia and
its inverse to be set to zero.</p>

<h3 style='margin-left:0in;text-indent:0in'>Bullets</h3>

<p class=MsoNormal>Game simulation usually generates a sequence of images that
are played at some frame rate. This is called discrete simulation. In discrete
simulation, rigid bodies can move by a large amount in one time step. If a
physics engine doesn't account for the large motion, you may see some objects
incorrectly pass through each other. This effect is called tunneling.</p>

<p class=MsoNormal>By default, Box2D uses continuous collision detection (CCD)
to prevent dynamic bodies from tunneling through static bodies. This is done by
sweeping shapes from their old position to their new positions. The engine
looks for new collisions during the sweep and computes the time of impact (TOI)
for these collisions. Bodies are moved to their first TOI and then halted for
the remainder of the time step.</p>

<p class=MsoNormal>Normally CCD is not used between dynamic bodies. This is
done to keep performance reasonable. In some game scenarios you need dynamic
bodies to use CCD. For example, you may want to shoot a high speed bullet at a
stack of dynamic bricks. Without CCD, the bullet might tunnel through the
bricks.</p>

<p class=MsoNormal>Fast moving objects in Box2D can be labeled as bullets.
Bullets will perform CCD with both static and dynamic bodies. You should decide
what bodies should be bullets based on your game design. If you decide a body
should be treated as a bullet, use the following setting.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>bodyDef.bullet = true;</p>

</div>

<p class=MsoNormal>The bullet flag only affects dynamic bodies.</p>

<p class=MsoNormal>Box2D performs continuous collision sequentially, so bullets
may miss fast moving bodies.</p>

<h3 style='margin-left:0in;text-indent:0in'>Activation</h3>

<p class=MsoNormal>You may wish a body to be created but not participate in
collision or dynamics. This state is similar to sleeping except the body will
not be woken by other bodies and the body's fixtures will not be placed in the
broad-phase. This means the body will not participate in collisions, ray casts,
etc.</p>

<p class=MsoNormal>You can create a body in an inactive state and later
re-activate it.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>bodyDef.active = true;</p>

</div>

<p class=MsoNormal>Joints may be connected to inactive bodies. These joints
will not be simulated. You should be careful when you activate a body that its
joints are not distorted.</p>

<h3 style='margin-left:0in;text-indent:0in'>User Data</h3>

<p class=MsoNormal>User data is a void pointer. This gives you a hook to link
your application objects to bodies. You should be consistent to use the same
object type for all body user data.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2BodyDef bodyDef;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bodyDef.userData = &amp;myActor;</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>7.3 Body Factory</h2>

</div>

<p class=MsoNormal>Bodies are created and destroyed using a body factory
provided by the world class. This lets the world create the body with an
efficient allocator and add the body to the world data structure.</p>

<p class=MsoNormal>Bodies can be dynamic or static depending on the mass
properties. Both body types use the same creation and destruction methods.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Body* dynamicBody =
myWorld-&gt;CreateBody(&amp;bodyDef);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>... do stuff ...</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>myWorld-&gt;DestroyBody(dynamicBody);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>dynamicBody = NULL;</p>

</div>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>You should never use new
or malloc to create a body. The world won't know about the body and the body
won't be properly initialized.</p>

</div>

<p class=MsoNormal>Static bodies do not move under the influence of other
bodies. You may manually move static bodies, but you should be careful so that
you don't squash dynamic bodies between two or more static bodies. Friction
will not work correctly if you move a static body. Static bodies never collide
with static or kinematic bodies. It is faster to attach several shapes to a
static body than to create several static bodies with a single shape on each one.
Internally, Box2D sets the mass and inverse mass of static bodies to zero. This
makes the math work out so that most algorithms don't need to treat static
bodies as a special case.</p>

<p class=MsoNormal>Box2D does not keep a reference to the body definition or
any of the data it holds (except user data pointers). So you can create
temporary body definitions and reuse the same body definitions.</p>

<p class=MsoNormal>Box2D allows you to avoid destroying bodies by deleting your
b2World object, which does all the cleanup work for you. However, you should be
mindful to nullify body pointers that you keep in your game engine.</p>

<p class=MsoNormal>When you destroy a body, the attached fixtures and joints
are automatically destroyed. This has important implications for how you manage
shape and joint pointers.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>7.4 Using a Body</h2>

</div>

<p class=MsoNormal>After creating a body, there are many operations you can
perform on the body. These include setting mass properties, accessing position
and velocity, applying forces, and transforming points and vectors.</p>

<h3 style='margin-left:0in;text-indent:0in'>Mass Data</h3>

<p class=MsoNormal>Every body has a mass (scalar), center of mass (2-vector),
and rotational inertia (scalar). For static bodies, the mass and rotational
inertia are set to zero. When a body has fixed rotation, its rotational inertia
is zero.</p>

<p class=MsoNormal>Normally the mass properties of a body are established
automatically when fixtures are added to the body. You can also adjust the mass
of a body at run-time. This is usually done when you have special game scenarios
that require altering the mass.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>void SetMassData(const b2MassData* data);</p>

</div>

<p class=MsoNormal>After setting a body's mass directly, you may wish to revert
to the natural mass dictated by the fixtures. You can do this with:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>void ResetMassData();</p>

</div>

<p class=MsoNormal>The body's mass data is available through the following
functions:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetMass() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetInertia() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>const b2Vec2&amp; GetLocalCenter()
const;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void GetMassData(b2MassData* data)
const;</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>State Information</h3>

<p class=MsoNormal>There are many aspects to the body's state. You can access
this state data efficiently through the following functions:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetType(b2BodyType type);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2BodyType GetType();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetBullet(bool flag);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool IsBullet() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetSleepingAllowed(bool flag);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool IsSleepingAllowed() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetAwake(bool flag);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool IsAwake() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetActive(bool flag);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool IsActive() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetFixedRotation(bool flag);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool IsFixedRotation() const;</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>Position and Velocity</h3>

<p class=MsoNormal>You can access the position and rotation of a body. This is
common when rendering your associated game actor. You can also set the
position, although this is less common since you will normally use Box2D to simulate
movement.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool SetTransform(const b2Vec2&amp;
position, float32 angle);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>const b2Transform&amp;
GetTransform() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>const b2Vec2&amp; GetPosition()
const;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetAngle() const;</p>

</div>

<p class=MsoNormal>You can access the center of mass position in local and
world coordinates. Much of the internal simulation in Box2D uses the center of
mass. However, you should normally not need to access it. Instead you will
usually work with the body transform. For example, you may have a body that is
square. The body origin might be a corner of the square, while the center of
mass is located at the center of the square.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>const b2Vec2&amp; GetWorldCenter()
const;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>const b2Vec2&amp; GetLocalCenter()
const;</p>

</div>

<p class=MsoNormal>You can access the linear and angular velocity. The linear
velocity is for the center of mass. Therefore, the linear velocity may change
if the mass properties change.</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704170">Chapter 8 Joints</a></h1>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.1 About</h2>

</div>

<p class=MsoNormal>Joints are used to constrain bodies to the world or to each
other. Typical examples in games include ragdolls, teeters, and pulleys. Joints
can be combined in many different ways to create interesting motions.</p>

<p class=MsoNormal>Some joints provide limits so you can control the range of
motion. Some joint provide motors which can be used to drive the joint at a
prescribed speed until a prescribed force/torque is exceeded.</p>

<p class=MsoNormal>Joint motors can be used in many ways. You can use motors to
control position by specifying a joint velocity that is proportional to the
difference between the actual and desired position. You can also use motors to
simulate joint friction: set the joint velocity to zero and provide a small,
but significant maximum motor force/torque. Then the motor will attempt to keep
the joint from moving until the load becomes too strong.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.2 The Joint Definition</h2>

</div>

<p class=MsoNormal>Each joint type has a definition that derives from
b2JointDef. All joints are connected between two different bodies. One body may
static. Joints between static and/or kinematic bodies are allowed, but have no
effect and use some processing time.</p>

<p class=MsoNormal>You can specify user data for any joint type and you can
provide a flag to prevent the attached bodies from colliding with each other.
This is actually the default behavior and you must set the collideConnected
Boolean to allow collision between to connected bodies.</p>

<p class=MsoNormal>Many joint definitions require that you provide some
geometric data. Often a joint will be defined by anchor points. These are
points fixed in the attached bodies. Box2D requires these points to be
specified in local coordinates. This way the joint can be specified even when
the current body transforms violate the joint constraint --- a common occurrence
when a game is saved and reloaded. Additionally, some joint definitions need to
know the default relative angle between the bodies. This is necessary to
constrain rotation correctly.</p>

<p class=MsoNormal>Initializing the geometric data can be tedious, so many joints
have initialization functions that use the current body transforms to remove
much of the work. However, these initialization functions should usually only
be used for prototyping. Production code should define the geometry directly.
This will make joint behavior more robust.</p>

<p class=MsoNormal>The rest of the joint definition data depends on the joint
type. We cover these now.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.3 Joint Factory</h2>

</div>

<p class=MsoNormal>Joints are created and destroyed using the world factory
methods. This brings up an old issue:</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Don't try to create a
joint on the stack or on the heap using new or malloc. You must create and
destroy bodies and joints using the create and destroy methods of the b2World
class.</p>

</div>

<p class=MsoNormal>Here's an example of the lifetime of a revolute joint:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2RevoluteJointDef jointDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.body1 = myBody1;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.body2 = myBody2;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.anchorPoint =
myBody1-&gt;GetCenterPosition();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2RevoluteJoint* joint =
myWorld-&gt;CreateJoint(&amp;jointDef);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>... do stuff ...</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>myWorld-&gt;DestroyJoint(joint);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>joint = NULL;</p>

</div>

<p class=MsoNormal>It is always good to nullify your pointer after they are
destroyed. This will make the program crash in a controlled manner if you try
to reuse the pointer.</p>

<p class=MsoNormal>The lifetime of a joint is not simple. Heed this warning
well:</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Joints are destroyed
when an attached body is destroyed.</p>

</div>

<p class=MsoNormal>This precaution is not always necessary. You may organize
your game engine so that joints are always destroyed before the attached
bodies. In this case you don't need to implement the listener class. See the
section on Implicit Destruction for details.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.4 Using Joints</h2>

</div>

<p class=MsoNormal>Many simulations create the joints and don't access them
again until they are destroyed. However, there is a lot of useful data
contained in joints that you can use to create a rich simulation.</p>

<p class=MsoNormal>First of all, you can get the bodies, anchor points, and
user data from a joint.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Body* GetBody1();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Body* GetBody2();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 GetAnchor1();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 GetAnchor2();</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void* GetUserData();</p>

</div>

<p class=MsoNormal>All joints have a reaction force and torque. This the
reaction force applied to body 2 at the anchor point. You can use reaction
forces to break joints or trigger other game events. These functions may do
some computations, so don't call them if you don't need the result.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 GetReactionForce();</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetReactionTorque();</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.5 Distance Joint</h2>

</div>

<p class=MsoNormal>One of the simplest joint is a distance joint which says
that the distance between two points on two bodies must be constant. When you
specify a distance joint the two bodies should already be in place. Then you
specify the two anchor points in world coordinates. The first anchor point is
connected to body 1, and the second anchor point is connected to body 2. These
points imply the length of the distance constraint.</p>

<p class=MsoNormal><img border=0 width=155 height=118
src="manual_files/image012.gif" alt=distanceJoint.gif></p>

<p class=MsoNormal>Here is an example of a distance joint definition. In this
case we decide to allow the bodies to collide.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2DistanceJointDef jointDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.Initialize(myBody1,
myBody2, worldAnchorOnBody1, worldAnchorOnBody2);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.collideConnected = true;</p>

</div>

<p class=MsoNormal>The distance joint can also be made soft, like a
spring-damper connection. See the Web example in the testbed to see how this
behaves.</p>

<p class=MsoNormal>Softness is achieved by tuning two constants in the
definition: frequency and damping ratio. Think of the frequency as the
frequency of a harmonic oscillator (like a guitar string). The frequency is
specified in Hertz. Typically the frequency should be less than a half the
frequency of the time step. So if you are using a 60Hz time step, the frequency
of the distance joint should be less than 30Hz. The reason is related to the
Nyquist frequency.</p>

<p class=MsoNormal>The damping ratio is non-dimensional and is typically
between 0 and 1, but can be larger. At 1, the damping is critical (all
oscillations should vanish).</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.frequencyHz = 4.0f;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.dampingRatio = 0.5f;</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.6 Revolute Joint</h2>

</div>

<p class=MsoNormal>A revolute joint forces two bodies to share a common anchor
point, often called a hinge point. The revolute joint has a single degree of
freedom: the relative rotation of the two bodies. This is called the joint
angle.</p>

<p class=MsoNormal><img border=0 width=139 height=97
src="manual_files/image013.gif" alt=revoluteJoint.gif></p>

<p class=MsoNormal>To specify a revolute you need to provide two bodies and a
single anchor point in world space. The initialization function assumes that
the bodies are already in the correct position.</p>

<p class=MsoNormal>In this example, two bodies are connected by a revolute
joint at the first body's center of mass.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2RevoluteJointDef jointDef;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.Initialize(myBody1,
myBody2, myBody1-&gt;GetWorldCenter());</p>

</div>

<p class=MsoNormal>The revolute joint angle is positive when body2 rotates CCW
about the angle point. Like all angles in Box2D, the revolute angle is measured
in radians. By convention the revolute joint angle is zero when the joint is
created using Initialize(), regardless of the current rotation of the two
bodies.</p>

<p class=MsoNormal>In some cases you might wish to control the joint angle. For
this, the revolute joint can optionally simulate a joint limit and/or a motor.</p>

<p class=MsoNormal>A joint limit forces the joint angle to remain between a
lower and upper bound. The limit will apply as much torque as needed to make
this happen. The limit range should include zero, otherwise the joint will
lurch when the simulation begins.</p>

<p class=MsoNormal>A joint motor allows you to specify the joint speed (the
time derivative of the angle). The speed can be negative or positive. A motor
can have infinite force, but this is usually not desirable. Recall the eternal
question:</p>

<p class=MsoQuote>&quot;What happens when an irresistible force meets an
immovable object?&quot;</p>

<p class=MsoNormal>I can tell you it's not pretty. So you can provide a maximum
torque for the joint motor. The joint motor will maintain the specified speed
unless the required torque exceeds the specified maximum. When the maximum
torque is exceeded, the joint will slow down and can even reverse.</p>

<p class=MsoNormal>You can use a joint motor to simulate joint friction. Just
set the joint speed to zero, and set the maximum torque to some small, but
significant value. The motor will try to prevent the joint from rotating, but
will yield to a significant load.</p>

<p class=MsoNormal>Here's a revision of the revolute joint definition above;
this time the joint has a limit and a motor enabled. The motor is setup to
simulate joint friction.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2RevoluteJointDef jointDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.Initialize(body1, body2,
myBody1-&gt;GetWorldCenter());</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.lowerAngle = -0.5f * b2_pi;
// -90 degrees</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.upperAngle = 0.25f * b2_pi;
// 45 degrees</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.enableLimit = true;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.maxMotorTorque = 10.0f;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.motorSpeed = 0.0f;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.enableMotor = true;</p>

</div>

<p class=MsoNormal>You can access a revolute joint's angle, speed, and motor
torque.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetJointAngle() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetJointSpeed() const;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetMotorTorque() const;</p>

</div>

<p class=MsoNormal>You also update the motor parameters each step.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetMotorSpeed(float32 speed);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetMaxMotorTorque(float32
torque);</p>

</div>

<p class=MsoNormal>Joint motors have some interesting abilities. You can update
the joint speed every time step so you can make the joint move back-and-forth
like a sine-wave or according to whatever function you want.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>... Game Loop Begin ...</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>myJoint-&gt;SetMotorSpeed(cosf(0.5f
* time));</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>... Game Loop End ...</p>

</div>

<p class=MsoNormal>You can also use joint motors to track a desired joint
angle. For example:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>... Game Loop Begin ...</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 angleError =
myJoint-&gt;GetJointAngle() - angleTarget;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 gain = 0.1f;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>myJoint-&gt;SetMotorSpeed(-gain *
angleError);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>... Game Loop End ...</p>

</div>

<p class=MsoNormal>Generally your gain parameter should not be too large.
Otherwise your joint may become unstable.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.7 Prismatic Joint</h2>

</div>

<p class=MsoNormal>A prismatic joint allows for relative translation of two
bodies along a specified axis. A prismatic joint prevents relative rotation.
Therefore, a prismatic joint has a single degree of freedom.</p>

<p class=MsoNormal><img border=0 width=165 height=134 id="Picture 1"
src="manual_files/image014.gif"></p>

<p class=MsoNormal>The prismatic joint definition is similar to the revolute
joint description; just substitute translation for angle and force for torque.
Using this analogy provides an example prismatic joint definition with a joint
limit and a friction motor:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2PrismaticJointDef jointDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 worldAxis(1.0f, 0.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.Initialize(myBody1,
myBody2, myBody1-&gt;GetWorldCenter(), worldAxis);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.lowerTranslation = -5.0f;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.upperTranslation = 2.5f;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.enableLimit = true;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.motorForce = 1.0f;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.motorSpeed = 0.0f;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.enableMotor = true;</p>

</div>

<p class=MsoNormal>The revolute joint has an implicit axis coming out of the
screen. The prismatic joint needs an explicit axis parallel to the screen. This
axis is fixed in the two bodies and follows their motion.</p>

<p class=MsoNormal>Like the revolute joint, the prismatic joint translation is
zero when the joint is created using Initialize(). So be sure zero is between
your lower and upper translation limits.</p>

<p class=MsoNormal>Using a prismatic joint is similar to using a revolute joint.
Here are the relevant member functions:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetJointTranslation() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetJointSpeed() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetMotorForce() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetMotorSpeed(float32 speed);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetMotorForce(float32 force);</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.8 Pulley Joint</h2>

</div>

<p class=MsoNormal>A pulley is used to create an idealized pulley. The pulley
connects two bodies to ground and to each other. As one body goes up, the other
goes down. The total length of the pulley rope is conserved according to the
initial configuration.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>length1 + length2 == constant</p>

</div>

<p class=MsoNormal>You can supply a ratio that simulates a block and tackle.
This causes one side of the pulley to extend faster than the other. At the same
time the constraint force is smaller on one side than the other. You can use
this to create mechanical leverage.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>length1 + ratio * length2 == constant</p>

</div>

<p class=MsoNormal>For example, if the ratio is 2, then length1 will vary at
twice the rate of length2. Also the force in the rope attached to body1 will
have half the constraint force as the rope attached to body2.</p>

<p class=MsoNormal><img border=0 width=237 height=213 id="Picture 2"
src="manual_files/image015.gif"></p>

<p class=MsoNormal>Pulleys can be troublesome when one side is fully extended.
The rope on the other side will have zero length. At this point the constraint
equations become singular (bad). Therefore the pulley joint constrains the
maximum length that either side can attain. Also, you may want to control the maximum
lengths for game play reasons. So the maximum lengths improve stability and
give you more control.</p>

<p class=MsoNormal>Here is an example pulley definition:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 anchor1 =
myBody1-&gt;GetWorldCenter();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 anchor2 =
myBody2-&gt;GetWorldCenter();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 groundAnchor1(p1.x, p1.y +
10.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 groundAnchor2(p2.x, p2.y +
12.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 ratio = 1.0f;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2PulleyJointDef jointDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.Initialize(myBody1,
myBody2, groundAnchor1, groundAnchor2, anchor1, anchor2, ratio);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.maxLength1 = 18.0f;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.maxLength2 = 20.0f;</p>

</div>

<p class=MsoNormal>Pulley joints provide the current lengths.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetLength1() const;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetLength2() const;</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.9 Gear Joint</h2>

</div>

<p class=MsoNormal>If you want to create a sophisticated mechanical contraption
you might want to use gears. In principle you can create gears in Box2D by using
compound shapes to model gear teeth. This is not very efficient and might be
tedious to author. You also have to be careful to line up the gears so the
teeth mesh smoothly. Box2D has a simpler method of creating gears:  the gear
joint.</p>

<p class=MsoNormal><img border=0 width=179 height=188 id="Picture 3"
src="manual_files/image016.gif"></p>

<p class=MsoNormal>The gear joint requires that you have two bodies connected
to ground by a revolute or prismatic joint. You can use any combination of
those joint types. Also, Box2D requires that the revolute and prismatic joints
were created with the ground as body1.</p>

<p class=MsoNormal>Like the pulley ratio, you can specify a gear ratio.
However, in this case the gear ratio can be negative. Also keep in mind that
when one joint is a revolute joint (angular) and the other joint is prismatic
(translation), and then the gear ratio will have units of length or one over
length.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>coordinate1 + ratio * coordinate2 ==
constant</p>

</div>

<p class=MsoNormal>Here is an example gear joint:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2GearJointDef jointDef;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.body1 = myBody1;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.body2 = myBody2;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.joint1 = myRevoluteJoint;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.joint2 = myPrismaticJoint;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>jointDef.ratio = 2.0f * b2_pi /
myLength;</p>

</div>

<p class=MsoNormal>Note that the gear joint depends on two other joints. This
creates a fragile situation. What happens if those joints are deleted?</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Always delete gear
joints before the revolute/prismatic joints on the gears. Otherwise your code
will crash in a bad way due to the orphaned joint pointers in the gear joint.
You should also delete the gear joint before you delete any of the bodies
involved.</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.10 Mouse Joint</h2>

</div>

<p class=MsoNormal>The mouse joint is used in the testbed to manipulate bodies
with the mouse. It attempts to drive a point on a body towards the current
position of the cursor. There is no restriction on rotation.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The mouse joint definition has a target point, maximum
force, frequency, and damping ratio. The target point initially coincides with
the body’s anchor point. The maximum force is used to prevent violent reactions
when multiple dynamic bodies interact. You can make this as large as you like.
The frequency and damping ratio are used to create a spring/damper effect
similar to the distance joint.</p>

<p class=MsoNormal> Many users have tried to adapt the mouse joint for game
play. Users often want to achieve precise positioning and instantaneous
response. The mouse joint doesn’t work very well in that context. You may wish
to consider using kinematic bodies instead.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.11 Line Joint</h2>

</div>

<p class=MsoNormal>The line joint is like the prismatic joint with the rotation
restriction removed. This was requested by a user to model a vehicle wheel with
a suspension. See b2LineJoint.h for details.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>8.12 Weld Joint</h2>

</div>

<p class=MsoNormal>The weld joint attempts to constrain all relative motion
between two bodies. See the Cantilever demo in the testbed to see how the weld
joint behaves.</p>

<p class=MsoNormal>It is tempting to use the weld joint to define breakable
structures. However, the Box2D solver is iterative so the joints are a bit
soft. So chains of bodies connected by weld joints will flex.</p>

<p class=MsoNormal>Instead it is better to create breakable bodies starting
with a single body with multiple fixtures. When the body breaks, you can
destroy a fixture and recreate it on a new body. See the Breakable example in
the testbed.</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704171">Chapter 9 Contacts</a></h1>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>9.1 About</h2>

</div>

<p class=MsoNormal>Contacts are objects created by Box2D to manage collision
between fixtures. There are different kinds of contacts, derived from
b2Contact, for managing contact between different kinds of fixtures. For
example there is a contact class for managing polygon-polygon collision and
another contact class for managing circle-circle collision.</p>

<p class=MsoNormal>Here is some terminology associated with contacts.</p>

<h3 style='margin-left:0in;text-indent:0in'>contact point</h3>

<p class=MsoNormal>A contact point is a point where two shapes touch. Box2D
approximates contact with a small number of points.</p>

<h3 style='margin-left:0in;text-indent:0in'>contact normal</h3>

<p class=MsoNormal>A contact normal is a unit vector that points from one shape
to another. By convention, the normal points from fixtureA to fixtureB.</p>

<h3 style='margin-left:0in;text-indent:0in'>contact separation</h3>

<p class=MsoNormal>Separation is the opposite of penetration. Separation is
negative when shapes overlap. It is possible that future versions of Box2D will
create contact points with positive separation, so you may want to check the
sign when contact points are reported.</p>

<h3 style='margin-left:0in;text-indent:0in'>contact manifold</h3>

<p class=MsoNormal>Contact between two convex polygons may generate up to 2
contact points. Both of these points use the same normal, so they are grouped
into a contact manifold, which is an approximation of a continuous region of
contact.</p>

<h3 style='margin-left:0in;text-indent:0in'>normal impulse</h3>

<p class=MsoNormal>The normal force is the force applied at a contact point to
prevent the shapes from penetrating. For convenience, Box2D works with
impulses. The normal impulse is just the normal force multiplied by the time
step.</p>

<h3 style='margin-left:0in;text-indent:0in'>tangent impulse</h3>

<p class=MsoNormal>The tangent force is generated at a contact point to
simulate friction. For convenience, this is stored as an impulse.</p>

<h3 style='margin-left:0in;text-indent:0in'>contact ids</h3>

<p class=MsoNormal>Box2D tries to re-use the contact force results from a time
step as the initial guess for the next time step. Box2D uses contact ids to
match contact points across time steps. The ids contain geometric features
indices that help to distinguish one contact point from another.</p>

<p class=MsoNormal>Contacts are created when two fixture’s AABBs overlap.
Sometimes collision filtering will prevent the creation of contacts. Contacts
are destroyed with the AABBs cease to overlap.</p>

<p class=MsoNormal>So you might gather that there may be contacts created for fixtures
that are not touching (just their AABBs). Well, this is correct. It's a
&quot;chicken or egg&quot; problem. We don't know if we need a contact object
until one is created to analyze the collision. We could delete the contact
right away if the shapes are not touching, or we can just wait until the AABBs
stop overlapping. Box2D takes the latter approach because it lets the system
cache information to improve performance.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>9.2 Contact Class</h2>

</div>

<p class=MsoNormal>As mentioned before, the contact class is created and
destroyed by Box2D. Contact objects are not created by the user. However, you
are able to access the contact class and interact with it.</p>

<p class=MsoNormal>You can access the raw contact manifold:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Manifold* GetManifold();</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>const b2Manifold* GetManifold()
const;</p>

</div>

<p class=MsoNormal>You can potentially modify the manifold, but this is
generally not supported and is for advanced usage.</p>

<p class=MsoNormal>There is a helper function to get the b2WorldManifold:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>void GetWorldManifold(b2WorldManifold*
worldManifold) const;</p>

</div>

<p class=MsoNormal>This uses the current positions of the bodies to compute
world positions of the contact points.</p>

<p class=MsoNormal>Sensors do not create manifolds, so for them use:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>bool touching =
sensorContact-&gt;IsTouching();</p>

</div>

<p class=MsoNormal>This function also works for non-sensors.</p>

<p class=MsoNormal>You can get the fixtures from a contact. From those you can
get the bodies.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Fixture* fixtureA =
myContact-&gt;GetFixtureA();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Body* bodyA =
fixtureA-&gt;GetBody();</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>MyActor* actorA =
(MyActor*)bodyA-&gt;GetUserData();</p>

</div>

<p class=MsoNormal>You can disable a contact. This only works inside the
b2ContactListener::PreSolve event, discussed below.</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>9.3 Accessing Contacts</h2>

</div>

<p class=MsoNormal>You can get access to contacts in several ways. You can
access the contacts directly on the world and body structures. You can also implement
a contact listener.</p>

<p class=MsoNormal>You can iterate over all contacts in the world:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>for (b2Contact* c =
myWorld-&gt;GetContactList(); c; c = c-&gt;GetNext())</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  // process c</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>You can also iterate over all the contacts on a body. These
are stored in a graph using a contact edge structure.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>for (b2ContactEdge* ce =
myBody-&gt;GetContactList(); ce; ce = ce-&gt;next)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  b2Contact* c = ce-&gt;contact;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  // process c</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>You can also access contacts using the contact listener that
is described below.</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Accessing contacts off b2World
and b2Body may miss some transient contacts that occur in the middle of the
time step. Use b2ContactListener to get the most accurate results.</p>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>9.4 Contact Listener</h2>

</div>

<p class=MsoNormal>You can receive contact data by implementing
b2ContactListener. The contact listener supports several events: begin, end,
pre-solve, and post-solve.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>class MyContactListener : public
b2ContactListener</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>public:</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  void BeginContact(b2Contact*
contact)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  { // handle begin event }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  void EndContact(b2Contact* contact)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  { // handle end event }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  void PreSolve(b2Contact* contact,
const b2Manifold* oldManifold)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  { // handle pre-solve event }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  void PostSolve(b2Contact* contact,
const b2ContactImpulse* impulse)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  { // handle post-solve event }</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>};</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Do not keep a reference
to the pointers sent to b2ContactListener. Instead make a deep copy of the
contact point data into your own buffer. The example below shows one way of
doing this.</p>

</div>

<p class=MsoNormal>At run-time you can create an instance of the listener and
register it with b2World::SetContactListener. Be sure your listener remains in
scope while the world object exists.</p>

<h3 style='margin-left:0in;text-indent:0in'>Begin Contact Event</h3>

<p class=MsoNormal>This is called when two fixtures begin to overlap. This is
called for sensors and non-sensors. This event can only occur inside the time
step.</p>

<h3 style='margin-left:0in;text-indent:0in'> End Contact Event</h3>

<p class=MsoNormal>This is called when two fixtures cease to overlap. This is
called for sensors and non-sensors. This may be called when a body is
destroyed, so this event can occur outside the time step.</p>

<h3 style='margin-left:0in;text-indent:0in'>Pre-Solve Event</h3>

<p class=MsoNormal>This is called after collision detection, but before
collision resolution. This gives you a chance to disable the contact based on
the current configuration. For example, you can implement a one-sided platform
using this callback and calling b2Contact::SetEnabled(false). The contact will
be re-enabled each time through collision processing, so you will need to
disable the contact every time-step. The pre-solve event may be fired multiple
times per time step per contact due to continuous collision detection.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void PreSolve(b2Contact* contact,
const b2Manifold* oldManifold)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  b2WorldManifold worldManifold;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'> 
contact-&gt;GetWorldManifold(&amp;worldManifold);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  if (worldManifold.normal.y &lt;
-0.5f)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    contact-&gt;SetEnabled(false);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  }</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>The pre-solve event is also a good place to determine the
point state and the approach velocity of collisions.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void PreSolve(b2Contact* contact,
const b2Manifold* oldManifold)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  b2WorldManifold worldManifold;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'> 
contact-&gt;GetWorldManifold(&amp;worldManifold);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  b2PointState state1[2], state2[2];</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  b2GetPointStates(state1, state2,
oldManifold, contact-&gt;GetManifold());</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  if (state2[0] == b2_addState)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    const b2Body* bodyA =
contact-&gt;GetFixtureA()-&gt;GetBody();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    const b2Body* bodyB =
contact-&gt;GetFixtureB()-&gt;GetBody();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Vec2 point = worldManifold.points[0];</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Vec2 vA = bodyA-&gt;GetLinearVelocityFromWorldPoint(point);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Vec2 vB =
bodyB-&gt;GetLinearVelocityFromWorldPoint(point);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    float32 approachVelocity =
b2Dot(vB – vA, worldManifold.normal);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    if (approachVelocity &gt; 1.0f)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>      MyPlayCollisionSound();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>  }</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>&nbsp;</h3>

<h3 style='margin-left:0in;text-indent:0in'>Post-Solve Event</h3>

<p class=MsoNormal>The post solve event is where you can gather collision
impulse results. If you don’t care about the impulses, you should probably just
implement the pre-solve event.</p>

<p class=MsoNormal>It is tempting to implement game logic that alters the
physics world inside a contact callback. For example, you may have a collision
that applies damage and try to destroy the associated actor and its rigid body.
However, Box2D does not allow you to alter the physics world inside a callback
because you might destroy objects that Box2D is currently processing, leading
to orphaned pointers. </p>

<p class=MsoNormal>The recommended practice for processing contact points is to
buffer all contact data that you care about and process it after the time step.
You should always process the contact points immediately after the time step;
otherwise some other client code might alter the physics world, invalidating
the contact buffer. When you process the contact buffer you can alter the
physics world, but you still need to be careful that you don't orphan pointers
stored in the contact point buffer. The testbed has example contact point
processing that is safe from orphaned pointers.</p>

<p class=MsoNormal>This code from the CollisionProcessing test shows how to
handle orphaned bodies when processing the contact buffer. Here is an excerpt.
Be sure to read the comments in the listing. This code assumes that all contact
points have been buffered in the b2ContactPoint array m_points.</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// We are going to destroy some
bodies according to contact</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// points. We must buffer the bodies
that should be destroyed</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// because they may belong to
multiple contact points.</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>const int32 k_maxNuke = 6;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Body* nuke[k_maxNuke];</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>int32 nukeCount = 0;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// Traverse the contact buffer.
Destroy bodies that</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// are touching heavier bodies.</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>for (int32 i = 0; i &lt;
m_pointCount; ++i)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    ContactPoint* point = m_points +
i;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Body* body1 =
point-&gt;shape1-&gt;GetBody();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Body* body2 =
point-&gt;shape2-&gt;GetBody();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    float32 mass1 =
body1-&gt;GetMass();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    float32 mass2 = body2-&gt;GetMass();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    if (mass1 &gt; 0.0f &amp;&amp;
mass2 &gt; 0.0f)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        if (mass2 &gt; mass1)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>            nuke[nukeCount++] =
body1;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        else</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>            nuke[nukeCount++] =
body2;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        if (nukeCount == k_maxNuke)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>            break;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// Sort the nuke array to group
duplicates.</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>std::sort(nuke, nuke + nukeCount);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// Destroy the bodies, skipping
duplicates.</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>int32 i = 0;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>while (i &lt; nukeCount)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Body* b = nuke[i++];</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    while (i &lt; nukeCount
&amp;&amp; nuke[i] == b)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        ++i;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    m_world-&gt;DestroyBody(b);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>9.5 Contact Filtering</h2>

</div>

<p class=MsoNormal>Often in a game you don't want all objects to collide. For
example, you may want to create a door that only certain characters can pass
through. This is called contact filtering, because some interactions are
filtered out.</p>

<p class=MsoNormal>Box2D allows you to achieve custom contact filtering by
implementing a b2ContactFilter class. This class requires you to implement a
ShouldCollide function that receives two b2Shape pointers. Your function
returns true if the shapes should collide.</p>

<p class=MsoNormal>The default implementation of ShouldCollide uses the
b2FilterData defined in Chapter 6, Fixtures.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>bool
b2ContactFilter::ShouldCollide(b2Shape* shape1, b2Shape* shape2)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>   const b2FilterData&amp; filter1 =
shape1-&gt;GetFilterData();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>   const b2FilterData&amp; filter2 =
shape2-&gt;GetFilterData();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>   if (filter1.groupIndex ==
filter2.groupIndex &amp;&amp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>       filter1.groupIndex != 0)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>   {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>          return filter1.groupIndex
&gt; 0;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>   }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>   bool collide = (filter1.maskBits &amp;
filter2.categoryBits) != 0 &amp;&amp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>                  (filter1.categoryBits
&amp; filter2.maskBits) != 0;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>   return collide;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>At run-time you can create an instance of your contact
filter and register it with b2World::SetContactFilter. Make sure your filter
stays in scope while the world exists.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>MyContactFilter filter;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>world-&gt;SetContactFilter(&amp;filter);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// filter remains in scope …</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704172">Chapter 10 World
Class</a></h1>

</div>

<h3 style='margin-left:0in;text-indent:0in'><a name="_Toc253068197">About</a></h3>

<p class=MsoNormal>The b2World class contains the bodies and joints. It manages
all aspects of the simulation and allows for asynchronous queries (like AABB
queries and ray-casts). Much of your interactions with Box2D will be with a
b2World object.</p>

<h3 style='margin-left:0in;text-indent:0in'>Creating and Destroying a World</h3>

<p class=MsoNormal>Creating a world is fairly simple. You just need to provide
a gravity vector and a Boolean indicating if bodies can sleep. Usually you will
create and destroy a world using new and delete.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2World* myWorld = new
b2World(gravity, doSleep);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>... do stuff ...</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>delete myWorld;</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>Using a World</h3>

<p class=MsoNormal>The world class contains factories for creating and
destroying bodies and joints. These factories are discussed later in the
sections on bodies and joints. There are some other interactions with b2World
that I will cover now.</p>

<h3 style='margin-left:0in;text-indent:0in'>Simulation</h3>

<p class=MsoNormal>The world class is used to drive the simulation. You specify
a time step and a velocity and position iteration count. For example:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 timeStep = 1.0f / 60.f;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>int32 velocityIterations = 10;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>int32 positionIterations = 8;</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>myWorld-&gt;Step(timeStep,
velocityIterations, positionIterations);</p>

</div>

<p class=MsoNormal>After the time step you can examine your bodies and joints
for information. Most likely you will grab the position off the bodies so that
you can update your actors and render them. You can perform the time step
anywhere in your game loop, but you should be aware of the order of things. For
example, you must create bodies before the time step if you want to get
collision results for the new bodies in that frame.</p>

<p class=MsoNormal>As I discussed above in the HelloWorld tutorial, you should
use a fixed time step. By using a larger time step you can improve performance
in low frame rate scenarios. But generally you should use a time step no larger
than 1/30 seconds. A time step of 1/60 seconds will usually deliver a high
quality simulation.</p>

<p class=MsoNormal>The iteration count controls how many times the constraint
solver sweeps over all the contacts and joints in the world. More iteration
always yields a better simulation. But don't trade a small time step for a
large iteration count. 60Hz and 10 iterations is far better than 30Hz and 20
iterations.</p>

<p class=MsoNormal>After stepping, you should clear any forces you have applied
to your bodies. This is done with the command b2World::ClearForces. This lets
you take multiple sub-steps with the same force field.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>myWorld-&gt;ClearForces();</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>Exploring the World</h3>

<p class=MsoNormal>The world is a container for bodies, contacts, and joints.
You can grab the body, contact, and joint lists off the world and iterate over
them. For example, this code wakes up all the bodies in the world:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>for (b2Body* b =
myWorld-&gt;GetBodyList(); b; b = b-&gt;GetNext())</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b-&gt;WakeUp();</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>Unfortunately real programs can be more complicated. For
example, the following code is broken:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>for (b2Body* b =
myWorld-&gt;GetBodyList(); b; b = b-&gt;GetNext())</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    GameActor* myActor =
(GameActor*)b-&gt;GetUserData();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    if (myActor-&gt;IsDead())</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        myWorld-&gt;DestroyBody(b);
// ERROR: now GetNext returns garbage.</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>Everything goes ok until a body is destroyed. Once a body is
destroyed, its next pointer becomes invalid. So the call to b2Body::GetNext()
will return garbage. The solution to this is to copy the next pointer before
destroying the body.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Body* node =
myWorld-&gt;GetBodyList();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>while (node)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Body* b = node;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    node = node-&gt;GetNext();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    </p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    GameActor* myActor =
(GameActor*)b-&gt;GetUserData();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    if (myActor-&gt;IsDead())</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        myWorld-&gt;DestroyBody(b);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>This safely destroys the current body. However, you may want
to call a game function that may destroy multiple bodies. In this case you need
to be very careful. The solution is application specific, but for convenience
I'll show one method of solving the problem.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Body* node = myWorld-&gt;GetBodyList();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>while (node)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Body* b = node;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    node = node-&gt;GetNext();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    </p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    GameActor* myActor =
(GameActor*)b-&gt;GetUserData();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    if (myActor-&gt;IsDead())</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        bool otherBodiesDestroyed =
GameCrazyBodyDestroyer(b);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        if (otherBodiesDestroyed)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>            node =
myWorld-&gt;GetBodyList();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>Obviously to make this work, GameCrazyBodyDestroyer must be
honest about what it has destroyed.</p>

<h3 style='margin-left:0in;text-indent:0in'>AABB Queries</h3>

<p class=MsoNormal>Sometimes you want to determine all the shapes in a region.
The b2World class has a fast log(N) method for this using the broad-phase data
structure. You provide an AABB in world coordinates and an implementation of
b2QueryCallback. The world calls your class with each fixture whose AABB
overlaps the query AABB. Return true to continue the query, otherwise return
false. For example, the following code finds all the fixtures that potentially
intersect a specified AABB and wakes up all of the associated bodies.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>class MyQueryCallback : public
b2QueryCallback</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>public:</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    bool ReportFixture(b2Fixture*
fixture)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        b2Body* body =
fixture-&gt;GetBody();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        body-&gt;WakeUp();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        </p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        // Return true to continue
the query.</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        return true;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>};</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>...</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>MyQueryCallback callback;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2AABB aabb;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>aabb.lowerBound.Set(-1.0f, -1.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>aabb.upperBound.Set(1.0f, 1.0f);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>myWorld-&gt;Query(&amp;callback,
aabb);</p>

</div>

<p class=MsoNormal>You cannot make any assumptions about the order of the
callbacks.</p>

<h3 style='margin-left:0in;text-indent:0in'>Ray Casts</h3>

<p class=MsoNormal>You can use ray casts to do line-of-site checks, fire guns,
etc. You perform a ray cast by implementing a callback class and providing the
start and end points. The world class calls your class with each fixture hit by
the ray. Your callback is provided with the fixture, the point of intersection,
the unit normal vector, and the fractional distance along the ray. You cannot
make any assumptions about the order of the callbacks.</p>

<p class=MsoNormal>You control the continuation of the ray cast by returning a
fraction. Returning a fraction of zero indicates the ray cast should be
terminated. A fraction of one indicates the ray cast should continue as if no
hit occurred. If you return the fraction from the argument list, the ray will
be clipped to the current intersection point. So you can ray cast any shape,
ray cast all shapes, or ray cast the closest shape by returning the appropriate
fraction.</p>

<p class=MsoNormal>You may also return of fraction of -1 to filter the fixture.
Then the ray cast will proceed as if the fixture does not exist.</p>

<p class=MsoNormal>Here is an example:</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>// This class captures the closest
hit shape.</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>class MyRayCastCallback : public b2RayCastCallback</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>public:</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    MyRayCastCallback()</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        m_fixture = NULL;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    </p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    float32 ReportFixture(b2Fixture*
fixture, const b2Vec2&amp; point,</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>                                      const
b2Vec2&amp; normal, float32 fraction)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        m_fixture = fixture;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        m_point = point;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        m_normal = normal;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        m_fraction = fraction;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        return fraction;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    </p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Fixture* m_fixture;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Vec2 m_point;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    b2Vec2 m_normal;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    float32 m_fraction;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>};</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>&nbsp;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>MyRayCastCallback callback;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 point1(-1.0f, 0.0f);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 point2(3.0f, 1.0f);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>myWorld-&gt;RayCast(&amp;callback,
point1, point2);</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>Due to round-off errors,
ray casts can sneak through small cracks between polygons in your static
environment. If this is not acceptable in your application, please enlarge your
polygons slightly.</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetLinearVelocity(const
b2Vec2&amp; v);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 GetLinearVelocity() const;</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void SetAngularVelocity(float32
omega);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>float32 GetAngularVelocity() const;</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>Forces and Impulses</h3>

<p class=MsoNormal>You can apply forces, torques, and impulses to a body. When you
apply a force or an impulse, you provide a world point where the load is
applied. This often results in a torque about the center of mass.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void ApplyForce(const b2Vec2&amp;
force, const b2Vec2&amp; point);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void ApplyTorque(float32 torque);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void ApplyLinearImpulse(const
b2Vec2&amp; impulse, const b2Vec2&amp; point);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>void ApplyAngularImpulse(float32
impulse);</p>

</div>

<p class=MsoNormal>Applying a force, torque, or impulse wakes the body.
Sometimes this is undesirable. For example, you may be applying a steady force
and want to allow the body to sleep to improve performance. In this case you
can use the following code.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>if (myBody-&gt;IsAwake() == true)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    myBody-&gt;ApplyForce(myForce,
myPoint);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>Coordinate Transformations</h3>

<p class=MsoNormal>The body class has some utility functions to help you
transform points and vectors between local and world space. If you don't
understand these concepts, please read &quot;Essential Mathematics for Games
and Interactive Applications&quot; by Jim Van Verth and Lars Bishop. These
functions are efficient (when inlined).</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 GetWorldPoint(const
b2Vec2&amp; localPoint);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 GetWorldVector(const
b2Vec2&amp; localVector);</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 GetLocalPoint(const
b2Vec2&amp; worldPoint);</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>b2Vec2 GetLocalVector(const
b2Vec2&amp; worldVector);</p>

</div>

<h3 style='margin-left:0in;text-indent:0in'>Lists</h3>

<p class=MsoNormal>You can iterate over a body's fixtures. This is mainly
useful if you need to access the fixture's user data.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>for (b2Fixture* f =
body-&gt;GetFixtureList(); f; f = f-&gt;GetNext())</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    MyFixtureData* data =
(MyFixtureData*)f-&gt;GetUserData();</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    ... do something with data ...</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>}</p>

</div>

<p class=MsoNormal>You can similarly iterate over the body's joint list.</p>

<p class=MsoNormal>The body also provides a list of associated contacts. You
can use this to get information about the current contacts. Be careful, because
the contact list may not contain all the contacts that existed during the
previous time step.</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704173">Chapter 11 Loose
Ends</a></h1>

</div>

<div style='border:none;border-bottom:solid #A6A6A6 1.0pt;padding:0in 0in 1.0pt 0in'>

<h2 style='margin-left:0in;text-indent:0in'>11.1 Implicit Destruction</h2>

</div>

<p class=MsoNormal>Box2D doesn't use reference counting. So if you destroy a
body it is really gone. Accessing a pointer to a destroyed body has undefined
behavior. In other words, your program will likely crash and burn. To help fix
these problems, the debug build memory manager fills destroyed entities with
FDFDFDFD. This can help find problems more easily in some cases.</p>

<p class=MsoNormal>If you destroy a Box2D entity, it is up to you to make sure
you remove all references to the destroyed object. This is easy if you only
have a single reference to the entity. If you have multiple references, you
might consider implementing a handle class to wrap the raw pointer.</p>

<p class=MsoNormal>Often when using Box2D you will create and destroy many
bodies, shapes, and joints. Managing these entities is somewhat automated by
Box2D. If you destroy a body then all associated shapes and joints are
automatically destroyed. This is called implicit destruction.</p>

<p class=MsoNormal>When you destroy a body, all its attached shapes, joints,
and contacts are destroyed. This is called implicit destruction. Any body
connected to one of those joints and/or contacts is woken. This process is
usually convenient. However, you must be aware of one crucial issue:</p>

<div style='border:solid #A6A6A6 1.0pt;padding:1.0pt 4.0pt 4.0pt 4.0pt;
background:white;margin-left:.65in;margin-right:.65in'>

<p class=MsoIntenseQuoteCxSpFirst style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'><b>Caution</b></p>

<p class=MsoIntenseQuoteCxSpLast style='margin-top:10.0pt;margin-right:0in;
margin-bottom:14.0pt;margin-left:0in;background:white'>When a body is
destroyed, all shapes and joints attached to the body are automatically destroyed.
You must nullify any pointers you have to those shapes and joints. Otherwise,
your program will die horribly if you try to access or destroy those shapes or
joints later.</p>

</div>

<p class=MsoNormal>To help you nullify your joint pointers, Box2D provides a
listener class named b2WorldListener that you can implement and provide to your
world object. Then the world object will notify you when a joint is going to be
implicitly destroyed.</p>

<p class=MsoNormal>Implicit destruction is a great convenience in many cases.
It can also make your program fall apart. You may store pointers to shapes and
joints somewhere in your code. These pointers become orphaned when an
associated body is destroyed. The situation becomes worse when you consider
that joints are often created by a part of the code unrelated to management of
the associated body. For example, the testbed creates a b2MouseJoint for
interactive manipulation of bodies on the screen.</p>

<p class=MsoNormal>Box2D provides a callback mechanism to inform your
application when implicit destruction occurs. This gives your application a
chance to nullify the orphaned pointers. This callback mechanism is described
later in this manual.</p>

<p class=MsoNormal>You can implement a b2DestructionListener that allows
b2World to inform you when a shape or joint is implicitly destroyed because an
associated body was destroyed. This will help prevent your code from accessing
orphaned pointers.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlockCxSpFirst style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>class MyDestructionListener : public
b2DestructionListener</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>{</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    void SayGoodbye(b2Joint* joint)</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    {</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>        // remove all references to
joint.</p>

<p class=CodeBlockCxSpMiddle style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>    }</p>

<p class=CodeBlockCxSpLast style='margin-top:0in;margin-right:0in;margin-bottom:
12.0pt;margin-left:0in;background:#F2F2F2'>};</p>

</div>

<p class=MsoNormal>You can then register an instance of your destruction
listener with your world object. You should do this during world
initialization.</p>

<div style='border:solid #595959 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#F2F2F2;margin-left:.25in;margin-right:.25in'>

<p class=CodeBlock style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:0in;background:#F2F2F2'>myWorld-&gt;SetListener(myDestructionListener);</p>

</div>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704174">Chapter 12 Debug
Drawing</a></h1>

</div>

<p class=MsoNormal>You can implement the b2DebugDraw class to get detailed
drawing of the physics world. Here are the available entities:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>shape outlines</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>joint connectivity</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>core shapes (for continuous collision)</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>broad-phase axis-aligned bounding boxes (AABBs), including the world
AABB</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>polygon oriented bounding boxes (OBBs)</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>broad-phase pairs (potential contacts)</p>

<p class=MsoListParagraphCxSpLast style='margin-left:.75in;text-indent:-.5in'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>center of mass</p>

<p class=MsoNormal><img border=0 width=624 height=529 id="Picture 4"
src="manual_files/image017.jpg"></p>

<p class=MsoNormal>This is the preferred method of drawing these physics
entities, rather than accessing the data directly. The reason is that much of
the necessary data is internal and subject to change.</p>

<p class=MsoNormal>The testbed draws physics entities using the debug draw
facility and the contact listener, so it serves as the primary example of how
to implement debug drawing as well as how to draw contact points.</p>

<div style='border:none;border-bottom:double #BFBFBF 1.5pt;padding:0in 0in 1.0pt 0in'>

<h1 style='margin-left:0in;text-indent:0in'><a name="_Toc257704175">Chapter 13 References</a></h1>

</div>

<p class=MsoNormal>Erin Catto’s GDC Tutorials: <a
href="http://code.google.com/p/box2d/downloads/list">http://code.google.com/p/box2d/downloads/list</a></p>

<p class=MsoNormal>Collision Detection in Interactive 3D Environments, Gino van
den Bergen, 2004</p>

<p class=MsoNormal>Real-Time Collision Detection, Christer Ericson, 2005</p>

</div>

</body>

</html>
