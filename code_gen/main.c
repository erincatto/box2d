// SPDX-FileCopyrightText: 2025 Erin Catto
// SPDX-License-Identifier: MIT

#if defined( _MSC_VER ) && !defined( _CRT_SECURE_NO_WARNINGS )
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Generated functions for dynamic arrays
// Pros
// - type safe
// - easy debugging
// - bounds checking
// - forward declaration
// - generates functions (like C++ templates)
// - functions have https://en.wikipedia.org/wiki/Sequence_point
// - avoids stretchy buffer dropped pointer update bugs
// - easy unsafe access when bound limits are ensured (loops)
//
// Cons
// - code generation

// Growth factor: https://en.wikipedia.org/wiki/Dynamic_array
//
// The fragmentation problem with factor 2:
// When you double capacity, the new allocation is larger than the sum of all previous allocations:
//
// 1st allocation: 8 bytes
// 2nd allocation: 16 bytes
// 3rd allocation: 32 bytes (larger than 8 + 16 = 24)
//
// This means the memory freed from previous allocations can never be reused for future expansions
// of the same array. The allocator must always find fresh memory.
//
// Instead this implementation grows by 1.5x to balance memory usage and performance

// Note: this file was written with the help of an LLM

typedef enum GroupType
{
	NATIVE_GROUP = -1,
	ARENA_GROUP = 0,
	BODY_GROUP,
	CONTACT_GROUP,
	ISLAND_GROUP,
	JOINT_GROUP,
	WORLD_GROUP,
	SENSOR_GROUP,
	SHAPE_GROUP,
	SOLVER_GROUP,

	GROUP_COUNT
} GroupType;

typedef struct
{
	const char* name;
} Group;

Group groups[GROUP_COUNT] = {
	{ "arena" }, { "body" }, { "contact" }, { "island" }, { "joint" }, { "world" }, { "sensor" }, { "shape" }, { "solver" },
};

typedef struct
{
	const char* type;
	const char* prefix;
	GroupType group;
} ArrayType;

ArrayType types[] = {
	{ "int", "b2Int", NATIVE_GROUP },
	{ "b2ArenaEntry", "b2ArenaEntry", ARENA_GROUP },
	{ "b2Body", "b2Body", BODY_GROUP },
	{ "b2BodyMoveEvent", "b2BodyMoveEvent", WORLD_GROUP },
	{ "b2BodySim", "b2BodySim", BODY_GROUP },
	{ "b2BodyState", "b2BodyState", BODY_GROUP },
	{ "b2ChainShape", "b2ChainShape", SHAPE_GROUP },
	{ "b2Contact", "b2Contact", CONTACT_GROUP },
	{ "b2ContactBeginTouchEvent", "b2ContactBeginTouchEvent", WORLD_GROUP },
	{ "b2ContactEndTouchEvent", "b2ContactEndTouchEvent", WORLD_GROUP },
	{ "b2ContactHitEvent", "b2ContactHitEvent", WORLD_GROUP },
	{ "b2ContactSim", "b2ContactSim", CONTACT_GROUP },
	{ "b2Island", "b2Island", ISLAND_GROUP },
	{ "b2IslandSim", "b2IslandSim", ISLAND_GROUP },
	{ "b2Joint", "b2Joint", JOINT_GROUP },
	{ "b2JointEvent", "b2JointEvent", WORLD_GROUP },
	{ "b2JointSim", "b2JointSim", JOINT_GROUP },
	{ "b2Sensor", "b2Sensor", SENSOR_GROUP },
	{ "b2SensorBeginTouchEvent", "b2SensorBeginTouchEvent", WORLD_GROUP },
	{ "b2SensorEndTouchEvent", "b2SensorEndTouchEvent", WORLD_GROUP },
	{ "b2SensorTaskContext", "b2SensorTaskContext", SENSOR_GROUP },
	{ "b2Shape", "b2Shape", SHAPE_GROUP },
	{ "b2Visitor", "b2Visitor", SENSOR_GROUP },
	{ "b2SolverSet", "b2SolverSet", SOLVER_GROUP },
	{ "b2TaskContext", "b2TaskContext", WORLD_GROUP },
	{ "b2SensorHit", "b2SensorHit", SENSOR_GROUP },
};

void write_section_divider( FILE* f, const char* title )
{
	fprintf( f, "// =============================================================================\n" );
	fprintf( f, "// %s\n", title );
	fprintf( f, "// =============================================================================\n\n" );
}

void write_file_header( FILE* f, const char* description )
{
	fprintf( f,
			 "// SPDX-FileCopyrightText: 2025 Erin Catto\n"
			 "// SPDX-License-Identifier: MIT\n"
			 "\n"
			 "// Auto-generated by code_gen/main.c - DO NOT EDIT\n"
			 "// %s\n"
			 "\n",
			 description );
}

// =============================================================================
// Header Generation Functions
// =============================================================================

void write_declare_header( FILE* f )
{
	write_file_header( f, "Array type declarations" );
	fprintf( f, "#pragma once\n"
				"#include \"core.h\"\n"
				"\n" );

	write_section_divider( f, "Dynamic Array Declarations" );
	fprintf( f, "// These can be used without the type T being fully defined (forward declarations)\n"
				"// Each array type provides Create, Reserve, and Destroy functions\n" );
}

void write_inline_header( FILE** f )
{
	for ( int i = 0; i < GROUP_COUNT; ++i )
	{
		write_file_header( f[i], "Inline array functions" );
		fprintf( f[i], "#pragma once\n"
					   "\n"
					   "#include \"array.h\"\n"
					   "\n" );
	}
}

void write_source_header( FILE* f )
{
	write_file_header( f, "Array function implementations" );
	fprintf( f, "#include \"array.h\"\n"
				"#include \"body.h\"\n"
				"#include \"contact.h\"\n"
				"#include \"island.h\"\n"
				"#include \"joint.h\"\n"
				"#include \"physics_world.h\"\n"
				"#include \"sensor.h\"\n"
				"#include \"shape.h\"\n"
				"#include \"solver_set.h\"\n"
				"\n" );
}

// =============================================================================
// Declaration Generation
// =============================================================================

void write_declare( FILE* f, ArrayType* t )
{
	fprintf( f, "\n// %s\n", t->type );

	if ( t->group == NATIVE_GROUP )
	{

		fprintf( f,
				 "typedef struct\n"
				 "{\n"
				 "  %s* data;\n"
				 "  int count;\n"
				 "  int capacity;\n"
				 "} %sArray;\n"
				 "\n",
				 t->type, t->prefix );

		fprintf( f, "%sArray %sArray_Create(int capacity);\n", t->prefix, t->prefix );
		fprintf( f, "void %sArray_Reserve(%sArray* a, int newCapacity);\n", t->prefix, t->prefix );
		fprintf( f, "void %sArray_Destroy(%sArray* a);\n", t->prefix, t->prefix );
	}
	else
	{
		fprintf( f,
				 "typedef struct\n"
				 "{\n"
				 "  struct %s* data;\n"
				 "  int count;\n"
				 "  int capacity;\n"
				 "} %sArray;\n"
				 "\n",
				 t->type, t->prefix );

		fprintf( f, "%sArray %sArray_Create(int capacity);\n", t->prefix, t->prefix );
		fprintf( f, "void %sArray_Reserve(%sArray* a, int newCapacity);\n", t->prefix, t->prefix );
		fprintf( f, "void %sArray_Destroy(%sArray* a);\n", t->prefix, t->prefix );
	}
}

// =============================================================================
// Inline Function Generation
// =============================================================================

void write_inline( FILE* f, ArrayType* t )
{
	const char* type = t->type;
	const char* prefix = t->prefix;

	write_section_divider( f, prefix );

	// Resize array to exact count, expanding capacity if needed
	fprintf( f,
			 "static inline void %sArray_Resize(%sArray* a, int count)\n"
			 "{\n"
			 "  %sArray_Reserve(a, count);\n"
			 "  a->count = count;\n"
			 "}\n"
			 "\n",
			 prefix, prefix, prefix );

	// Get pointer to element at index (with bounds checking)
	fprintf( f,
			 "static inline %s* %sArray_Get(%sArray* a, int index)\n"
			 "{\n"
			 "  B2_ASSERT(0 <= index && index < a->count);\n"
			 "  return a->data + index;\n"
			 "}\n"
			 "\n",
			 type, prefix, prefix );

	// Add new element and return pointer to it (auto-expands capacity)
	fprintf( f,
			 "static inline %s* %sArray_Add(%sArray* a)\n"
			 "{\n"
			 "  if (a->count == a->capacity)\n"
			 "  {\n"
			 "\n"
			 "    int newCapacity = a->capacity < 2 ? 2 : a->capacity + (a->capacity >> 1);\n"
			 "    %sArray_Reserve(a, newCapacity);\n"
			 "  }\n"
			 "  a->count += 1;\n"
			 "  return a->data + (a->count - 1);\n"
			 "}\n"
			 "\n",
			 type, prefix, prefix, prefix );

	// Push value to end of array (auto-expands capacity)
	fprintf( f,
			 "static inline void %sArray_Push(%sArray* a, %s value)\n"
			 "{\n"
			 "  if (a->count == a->capacity)\n"
			 "  {\n"
			 "    int newCapacity = a->capacity < 2 ? 2 : a->capacity + (a->capacity >> 1);\n"
			 "    %sArray_Reserve(a, newCapacity);\n"
			 "  }\n"
			 "  a->data[a->count] = value;\n"
			 "  a->count += 1;\n"
			 "}\n"
			 "\n",
			 prefix, prefix, type, prefix );

	// Set element at index to value (with bounds checking)
	fprintf( f,
			 "static inline void %sArray_Set(%sArray* a, int index, %s value)\n"
			 "{\n"
			 "  B2_ASSERT(0 <= index && index < a->count);\n"
			 "  a->data[index] = value;\n"
			 "}\n"
			 "\n",
			 prefix, prefix, type );

	// Remove element at index by swapping with last element
	// If not the last element, swap with last element
	fprintf( f,
			 "static inline int %sArray_RemoveSwap(%sArray* a, int index)\n"
			 "{\n"
			 "  B2_ASSERT(0 <= index && index < a->count);\n"
			 "  int movedIndex = B2_NULL_INDEX;\n"
			 "\n"
			 "  if (index != a->count - 1)\n"
			 "  {\n"
			 "    movedIndex = a->count - 1;\n"
			 "    a->data[index] = a->data[movedIndex];\n"
			 "  }\n"
			 "\n"
			 "  a->count -= 1;\n"
			 "  return movedIndex;\n"
			 "}\n"
			 "\n",
			 prefix, prefix );

	// Remove and return last element
	fprintf( f,
			 "static inline %s %sArray_Pop(%sArray* a)\n"
			 "{\n"
			 "  B2_ASSERT(a->count > 0);\n"
			 "  %s value = a->data[a->count - 1];\n"
			 "  a->count -= 1;\n"
			 "  return value;\n"
			 "}\n"
			 "\n",
			 type, prefix, prefix, type );

	// Clear array (doesn't free memory, just resets count)
	fprintf( f,
			 "static inline void %sArray_Clear(%sArray* a)\n"
			 "{\n"
			 "  a->count = 0;\n"
			 "}\n"
			 "\n",
			 prefix, prefix );

	// Get total byte count of allocated memory
	fprintf( f,
			 "static inline int %sArray_ByteCount(%sArray* a)\n"
			 "{\n"
			 "  return (int)(a->capacity * sizeof(%s));\n"
			 "}\n"
			 "\n",
			 prefix, prefix, type );
}

// =============================================================================
// Source Implementation Generation
// =============================================================================

void write_source( FILE* f, ArrayType* t )
{
	const char* type = t->type;
	const char* prefix = t->prefix;

	write_section_divider( f, prefix );

	// Create array with initial capacity
	fprintf( f,
			 "%sArray %sArray_Create(int capacity)\n"
			 "{\n"
			 "  %sArray a = {0};\n"
			 "\n"
			 "  if (capacity > 0)\n"
			 "  {\n"
			 "    a.data = b2Alloc(capacity * sizeof(%s));\n"
			 "    a.capacity = capacity;\n"
			 "  }\n"
			 "\n"
			 "  return a;\n"
			 "}\n"
			 "\n",
			 prefix, prefix, prefix, type );

	// Reserve space for at least newCapacity elements
	fprintf( f,
			 "void %sArray_Reserve(%sArray* a, int newCapacity)\n"
			 "{\n"
			 "  // Early exit if no expansion needed\n"
			 "  if (newCapacity <= a->capacity)\n"
			 "  {\n"
			 "    return;\n"
			 "  }\n"
			 "\n"
			 "  // Grow allocation using b2GrowAlloc for optimal memory management\n"
			 "  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(%s), newCapacity * sizeof(%s));\n"
			 "  a->capacity = newCapacity;\n"
			 "}\n"
			 "\n",
			 prefix, prefix, type, type );

	// Destroy array and free all memory
	fprintf( f,
			 "void %sArray_Destroy(%sArray* a)\n"
			 "{\n"
			 "  b2Free(a->data, a->capacity * sizeof(%s));\n"
			 "\n"
			 "  // Reset all fields to safe values\n"
			 "  a->data = NULL;\n"
			 "  a->count = 0;\n"
			 "  a->capacity = 0;\n"
			 "}\n"
			 "\n",
			 prefix, prefix, type );
}

// =============================================================================
// Main Program
// =============================================================================

int main( void )
{
	printf( "Box2D Code Generator\n" );
	printf( "====================\n\n" );

	// Working directory must be the top level directory
	FILE* fileDecl = fopen( "./src/array.h", "w" );
	FILE* inlineFiles[GROUP_COUNT];

	bool inlineFileSuccess = true;
	for ( int i = 0; i < GROUP_COUNT; ++i )
	{
		char buffer[64];
		snprintf( buffer, sizeof( buffer ), "./src/array_%s.inl", groups[i].name );
		inlineFiles[i] = fopen( buffer, "w" );
		if ( inlineFiles[i] == NULL )
		{
			inlineFileSuccess = false;
		}
	}

	FILE* fileSrc = fopen( "./src/array.c", "w" );

	if ( fileDecl == NULL || inlineFileSuccess == false || fileSrc == NULL )
	{
		fprintf( stderr, "Error: Could not open output files for writing.\n" );
		fprintf( stderr, "Make sure the ./src/ directory exists and is writable.\n" );
		return 1;
	}

	// Write file headers
	write_declare_header( fileDecl );
	write_inline_header( inlineFiles );
	write_source_header( fileSrc );

	// Generate code for each type
	size_t typeCount = sizeof( types ) / sizeof( types[0] );
	printf( "Generating code for %zu array types...\n", typeCount );

	for ( size_t i = 0; i < typeCount; ++i )
	{
		printf( "  - %sArray Group %d\n", types[i].prefix, types[i].group );

		write_declare( fileDecl, &types[i] );

		if ( types[i].group != NATIVE_GROUP )
		{
			int group = types[i].group;
			assert( 0 <= group && group < GROUP_COUNT );
			write_inline( inlineFiles[group], &types[i] );
		}

		write_source( fileSrc, &types[i] );
	}

	// Inline native types in decl file
	fprintf( fileDecl, "\n// Inline functions for native types.\n\n" );
	for ( size_t i = 0; i < typeCount; ++i )
	{
		if ( types[i].group == NATIVE_GROUP )
		{
			write_inline( fileDecl, &types[i] );
		}
	}

	// Close files
	fclose( fileDecl );

	for ( int i = 0; i < GROUP_COUNT; ++i )
	{
		fclose( inlineFiles[i] );
	}

	fclose( fileSrc );

	printf( "\nCode generation complete!\n" );
	printf( "Files created:\n" );
	printf( "  - ./src/array.h  (declarations)\n" );
	printf( "  - %d inline files\n", GROUP_COUNT );
	printf( "  - ./src/array.c          (implementations)\n" );

	return 0;
}
