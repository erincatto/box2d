// SPDX-FileCopyrightText: 2025 Erin Catto
// SPDX-License-Identifier: MIT

// Auto-generated by code_gen/main.c - DO NOT EDIT
// Array function implementations

#include "array.h"
#include "body.h"
#include "contact.h"
#include "island.h"
#include "joint.h"
#include "physics_world.h"
#include "sensor.h"
#include "shape.h"
#include "solver_set.h"

// =============================================================================
// b2Int
// =============================================================================

b2IntArray b2IntArray_Create(int capacity)
{
  b2IntArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(int));
    a.capacity = capacity;
  }

  return a;
}

void b2IntArray_Reserve(b2IntArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(int), newCapacity * sizeof(int));
  a->capacity = newCapacity;
}

void b2IntArray_Destroy(b2IntArray* a)
{
  b2Free(a->data, a->capacity * sizeof(int));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2ArenaEntry
// =============================================================================

b2ArenaEntryArray b2ArenaEntryArray_Create(int capacity)
{
  b2ArenaEntryArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2ArenaEntry));
    a.capacity = capacity;
  }

  return a;
}

void b2ArenaEntryArray_Reserve(b2ArenaEntryArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2ArenaEntry), newCapacity * sizeof(b2ArenaEntry));
  a->capacity = newCapacity;
}

void b2ArenaEntryArray_Destroy(b2ArenaEntryArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2ArenaEntry));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2Body
// =============================================================================

b2BodyArray b2BodyArray_Create(int capacity)
{
  b2BodyArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2Body));
    a.capacity = capacity;
  }

  return a;
}

void b2BodyArray_Reserve(b2BodyArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2Body), newCapacity * sizeof(b2Body));
  a->capacity = newCapacity;
}

void b2BodyArray_Destroy(b2BodyArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2Body));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2BodyMoveEvent
// =============================================================================

b2BodyMoveEventArray b2BodyMoveEventArray_Create(int capacity)
{
  b2BodyMoveEventArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2BodyMoveEvent));
    a.capacity = capacity;
  }

  return a;
}

void b2BodyMoveEventArray_Reserve(b2BodyMoveEventArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2BodyMoveEvent), newCapacity * sizeof(b2BodyMoveEvent));
  a->capacity = newCapacity;
}

void b2BodyMoveEventArray_Destroy(b2BodyMoveEventArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2BodyMoveEvent));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2BodySim
// =============================================================================

b2BodySimArray b2BodySimArray_Create(int capacity)
{
  b2BodySimArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2BodySim));
    a.capacity = capacity;
  }

  return a;
}

void b2BodySimArray_Reserve(b2BodySimArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2BodySim), newCapacity * sizeof(b2BodySim));
  a->capacity = newCapacity;
}

void b2BodySimArray_Destroy(b2BodySimArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2BodySim));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2BodyState
// =============================================================================

b2BodyStateArray b2BodyStateArray_Create(int capacity)
{
  b2BodyStateArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2BodyState));
    a.capacity = capacity;
  }

  return a;
}

void b2BodyStateArray_Reserve(b2BodyStateArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2BodyState), newCapacity * sizeof(b2BodyState));
  a->capacity = newCapacity;
}

void b2BodyStateArray_Destroy(b2BodyStateArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2BodyState));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2ChainShape
// =============================================================================

b2ChainShapeArray b2ChainShapeArray_Create(int capacity)
{
  b2ChainShapeArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2ChainShape));
    a.capacity = capacity;
  }

  return a;
}

void b2ChainShapeArray_Reserve(b2ChainShapeArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2ChainShape), newCapacity * sizeof(b2ChainShape));
  a->capacity = newCapacity;
}

void b2ChainShapeArray_Destroy(b2ChainShapeArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2ChainShape));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2Contact
// =============================================================================

b2ContactArray b2ContactArray_Create(int capacity)
{
  b2ContactArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2Contact));
    a.capacity = capacity;
  }

  return a;
}

void b2ContactArray_Reserve(b2ContactArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2Contact), newCapacity * sizeof(b2Contact));
  a->capacity = newCapacity;
}

void b2ContactArray_Destroy(b2ContactArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2Contact));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2ContactBeginTouchEvent
// =============================================================================

b2ContactBeginTouchEventArray b2ContactBeginTouchEventArray_Create(int capacity)
{
  b2ContactBeginTouchEventArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2ContactBeginTouchEvent));
    a.capacity = capacity;
  }

  return a;
}

void b2ContactBeginTouchEventArray_Reserve(b2ContactBeginTouchEventArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2ContactBeginTouchEvent), newCapacity * sizeof(b2ContactBeginTouchEvent));
  a->capacity = newCapacity;
}

void b2ContactBeginTouchEventArray_Destroy(b2ContactBeginTouchEventArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2ContactBeginTouchEvent));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2ContactEndTouchEvent
// =============================================================================

b2ContactEndTouchEventArray b2ContactEndTouchEventArray_Create(int capacity)
{
  b2ContactEndTouchEventArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2ContactEndTouchEvent));
    a.capacity = capacity;
  }

  return a;
}

void b2ContactEndTouchEventArray_Reserve(b2ContactEndTouchEventArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2ContactEndTouchEvent), newCapacity * sizeof(b2ContactEndTouchEvent));
  a->capacity = newCapacity;
}

void b2ContactEndTouchEventArray_Destroy(b2ContactEndTouchEventArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2ContactEndTouchEvent));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2ContactHitEvent
// =============================================================================

b2ContactHitEventArray b2ContactHitEventArray_Create(int capacity)
{
  b2ContactHitEventArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2ContactHitEvent));
    a.capacity = capacity;
  }

  return a;
}

void b2ContactHitEventArray_Reserve(b2ContactHitEventArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2ContactHitEvent), newCapacity * sizeof(b2ContactHitEvent));
  a->capacity = newCapacity;
}

void b2ContactHitEventArray_Destroy(b2ContactHitEventArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2ContactHitEvent));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2ContactSim
// =============================================================================

b2ContactSimArray b2ContactSimArray_Create(int capacity)
{
  b2ContactSimArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2ContactSim));
    a.capacity = capacity;
  }

  return a;
}

void b2ContactSimArray_Reserve(b2ContactSimArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2ContactSim), newCapacity * sizeof(b2ContactSim));
  a->capacity = newCapacity;
}

void b2ContactSimArray_Destroy(b2ContactSimArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2ContactSim));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2Island
// =============================================================================

b2IslandArray b2IslandArray_Create(int capacity)
{
  b2IslandArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2Island));
    a.capacity = capacity;
  }

  return a;
}

void b2IslandArray_Reserve(b2IslandArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2Island), newCapacity * sizeof(b2Island));
  a->capacity = newCapacity;
}

void b2IslandArray_Destroy(b2IslandArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2Island));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2IslandSim
// =============================================================================

b2IslandSimArray b2IslandSimArray_Create(int capacity)
{
  b2IslandSimArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2IslandSim));
    a.capacity = capacity;
  }

  return a;
}

void b2IslandSimArray_Reserve(b2IslandSimArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2IslandSim), newCapacity * sizeof(b2IslandSim));
  a->capacity = newCapacity;
}

void b2IslandSimArray_Destroy(b2IslandSimArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2IslandSim));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2Joint
// =============================================================================

b2JointArray b2JointArray_Create(int capacity)
{
  b2JointArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2Joint));
    a.capacity = capacity;
  }

  return a;
}

void b2JointArray_Reserve(b2JointArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2Joint), newCapacity * sizeof(b2Joint));
  a->capacity = newCapacity;
}

void b2JointArray_Destroy(b2JointArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2Joint));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2JointEvent
// =============================================================================

b2JointEventArray b2JointEventArray_Create(int capacity)
{
  b2JointEventArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2JointEvent));
    a.capacity = capacity;
  }

  return a;
}

void b2JointEventArray_Reserve(b2JointEventArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2JointEvent), newCapacity * sizeof(b2JointEvent));
  a->capacity = newCapacity;
}

void b2JointEventArray_Destroy(b2JointEventArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2JointEvent));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2JointSim
// =============================================================================

b2JointSimArray b2JointSimArray_Create(int capacity)
{
  b2JointSimArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2JointSim));
    a.capacity = capacity;
  }

  return a;
}

void b2JointSimArray_Reserve(b2JointSimArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2JointSim), newCapacity * sizeof(b2JointSim));
  a->capacity = newCapacity;
}

void b2JointSimArray_Destroy(b2JointSimArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2JointSim));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2Sensor
// =============================================================================

b2SensorArray b2SensorArray_Create(int capacity)
{
  b2SensorArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2Sensor));
    a.capacity = capacity;
  }

  return a;
}

void b2SensorArray_Reserve(b2SensorArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2Sensor), newCapacity * sizeof(b2Sensor));
  a->capacity = newCapacity;
}

void b2SensorArray_Destroy(b2SensorArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2Sensor));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2SensorBeginTouchEvent
// =============================================================================

b2SensorBeginTouchEventArray b2SensorBeginTouchEventArray_Create(int capacity)
{
  b2SensorBeginTouchEventArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2SensorBeginTouchEvent));
    a.capacity = capacity;
  }

  return a;
}

void b2SensorBeginTouchEventArray_Reserve(b2SensorBeginTouchEventArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2SensorBeginTouchEvent), newCapacity * sizeof(b2SensorBeginTouchEvent));
  a->capacity = newCapacity;
}

void b2SensorBeginTouchEventArray_Destroy(b2SensorBeginTouchEventArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2SensorBeginTouchEvent));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2SensorEndTouchEvent
// =============================================================================

b2SensorEndTouchEventArray b2SensorEndTouchEventArray_Create(int capacity)
{
  b2SensorEndTouchEventArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2SensorEndTouchEvent));
    a.capacity = capacity;
  }

  return a;
}

void b2SensorEndTouchEventArray_Reserve(b2SensorEndTouchEventArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2SensorEndTouchEvent), newCapacity * sizeof(b2SensorEndTouchEvent));
  a->capacity = newCapacity;
}

void b2SensorEndTouchEventArray_Destroy(b2SensorEndTouchEventArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2SensorEndTouchEvent));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2SensorTaskContext
// =============================================================================

b2SensorTaskContextArray b2SensorTaskContextArray_Create(int capacity)
{
  b2SensorTaskContextArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2SensorTaskContext));
    a.capacity = capacity;
  }

  return a;
}

void b2SensorTaskContextArray_Reserve(b2SensorTaskContextArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2SensorTaskContext), newCapacity * sizeof(b2SensorTaskContext));
  a->capacity = newCapacity;
}

void b2SensorTaskContextArray_Destroy(b2SensorTaskContextArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2SensorTaskContext));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2Shape
// =============================================================================

b2ShapeArray b2ShapeArray_Create(int capacity)
{
  b2ShapeArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2Shape));
    a.capacity = capacity;
  }

  return a;
}

void b2ShapeArray_Reserve(b2ShapeArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2Shape), newCapacity * sizeof(b2Shape));
  a->capacity = newCapacity;
}

void b2ShapeArray_Destroy(b2ShapeArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2Shape));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2Visitor
// =============================================================================

b2VisitorArray b2VisitorArray_Create(int capacity)
{
  b2VisitorArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2Visitor));
    a.capacity = capacity;
  }

  return a;
}

void b2VisitorArray_Reserve(b2VisitorArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2Visitor), newCapacity * sizeof(b2Visitor));
  a->capacity = newCapacity;
}

void b2VisitorArray_Destroy(b2VisitorArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2Visitor));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2SolverSet
// =============================================================================

b2SolverSetArray b2SolverSetArray_Create(int capacity)
{
  b2SolverSetArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2SolverSet));
    a.capacity = capacity;
  }

  return a;
}

void b2SolverSetArray_Reserve(b2SolverSetArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2SolverSet), newCapacity * sizeof(b2SolverSet));
  a->capacity = newCapacity;
}

void b2SolverSetArray_Destroy(b2SolverSetArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2SolverSet));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2TaskContext
// =============================================================================

b2TaskContextArray b2TaskContextArray_Create(int capacity)
{
  b2TaskContextArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2TaskContext));
    a.capacity = capacity;
  }

  return a;
}

void b2TaskContextArray_Reserve(b2TaskContextArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2TaskContext), newCapacity * sizeof(b2TaskContext));
  a->capacity = newCapacity;
}

void b2TaskContextArray_Destroy(b2TaskContextArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2TaskContext));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

// =============================================================================
// b2SensorHit
// =============================================================================

b2SensorHitArray b2SensorHitArray_Create(int capacity)
{
  b2SensorHitArray a = {0};

  if (capacity > 0)
  {
    a.data = b2Alloc(capacity * sizeof(b2SensorHit));
    a.capacity = capacity;
  }

  return a;
}

void b2SensorHitArray_Reserve(b2SensorHitArray* a, int newCapacity)
{
  // Early exit if no expansion needed
  if (newCapacity <= a->capacity)
  {
    return;
  }

  // Grow allocation using b2GrowAlloc for optimal memory management
  a->data = b2GrowAlloc(a->data, a->capacity * sizeof(b2SensorHit), newCapacity * sizeof(b2SensorHit));
  a->capacity = newCapacity;
}

void b2SensorHitArray_Destroy(b2SensorHitArray* a)
{
  b2Free(a->data, a->capacity * sizeof(b2SensorHit));

  // Reset all fields to safe values
  a->data = NULL;
  a->count = 0;
  a->capacity = 0;
}

